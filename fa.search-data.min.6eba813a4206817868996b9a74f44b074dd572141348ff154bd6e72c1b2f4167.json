[{"id":0,"href":"/fa/docs/measure-internet-censorship/","title":"بررسی سانسور اینترنت: مقدمه","section":"Docs","content":" بررسی سانسور اینترنت # مقدمه # امروزه اینترنت بخش مهم زندگی اکثر مردم جهان شده است. و برای بعضی از افراد، همچون هوا، ضروری است. به حدی که به عنوان حقوق اولیه ی هر انسانی به شمار می آید. اما در بعضی کشورها همچون ایران، حقوق مردم در هر سمت مورد تعرض قرار می گیرد. سرویس های مهم خارجی که بخش اصلی منابع مهم دنیا و تکنولوژی ها را در دست دارند، دسترسی ایرانی ها را محدود و یا مسدود کرده اند. سیستم سانسور جمهوری اسلامی هم، همراه با این محدودیت ها عمل کرده و برخی از این سرویس ها را برای مردم محدود و یا مسدود کرده است؛ به طریقی که سرویسی مانند «شکن» هم نمی تواند برای دور زدن این تحریم ها کاری انجام دهد. و یا اینکه سیستم سانسور جمهوری اسلامی، دائما در حال شناسایی و مسدود کردن سرور های پراکسی و VPN است که بخشی مهمی از آن برای دور زدن تحریم ها به کار گرفته می شود. اخیرا سیستم سانسور جمهوری اسلامی عملی انجام داده که به صورت پیشفرض امکان ارتباط HTTPS به سمت خیلی از سرویس های خارجی وجود نداشته باشد. به عبارتی تمام سرویس های خارجی که طبق استاندارد جهانی هستند اما طبق علاقه ی سیستم سانسور جمهوری اسلامی نیستند، محکوم به نابودی شدند. مانند تمام برنامه هایی که با زبان Go نوشته شده و در موبایل به کار گرفته می شوند و یا تمام ارتباطاتی که با ElectronJS نوشته شدند و تمایل به ارتباط با سرور های AWS آمازون و یا گیتهاب دارند. همچنین در بخش هایی نشان داده می شود که چطور سیستم سانسور جمهوری اسلامی به صورت random در ارتباطات اختلال ایجاد می کند.\nطبق آخرین تحقیقاتی که OONI انجام داده، می توان به یک نتیجه ای رسید که روش کار در بین خیلی از این حکومت های تمامیت خواه یکسان است. به عنوان مثال شیوه ای از اختلال موقتی در سرویس ها در ایران، قزاقستان و اوگاندا یکسان است و تقریبا از یک بازه ی زمانی شروع شده است.\nدر این شرایط بسیار سخت است تا متوجه شویم که ایراداتی که در ارتباطمان وجود دارد، از کجا نشات می گیرند. به همین دلیل تصمیم شروع نوشتن در این مورد کردم.\nتعاریف واژه ها و اصطلاحات # ابتدا چند تعریف انجام می شود که ممکن است بین همه مشترک نباشد اما از آنها استفاده خواهیم کرد که توضیحات کمتر شوند.\nشخص ناشناس # به تمام دستگاه ها و افرادی که بین دستگاه شما و سرور نهایی قرار میگیرند، اعم از مسئول شبکه ی ارائه دهنده ی خدمات اینترنت شما، دستگاه های سانسور، هکر یا بدافزار احتمالی در شبکه، سرور پراکسی و یا VPN، مسئول شبکه ی ارائه دهنده ی خدمات اینترنت سرور، را شخص ناشناس می گوییم. این شخص میتواند فقط نظارت داشته باشد و یا در شبکه و packet ها دستکاری انجام دهد و یا اطلاعاتی را سرقت کند.\n(با کمی تغییرات از طرح اصلی سازمان EFF)\nسیاهچاله # null route یا black hole route روشی است که packet ها توسط سیستم سانسور دور ریخته می شوند و به طریقی که درخواست کلاینت و یا درخواست سرور به یکدیگر نمی رسد را سیاه چاله می گوییم.\nدر این حالت ارتباط در حالت بلاتکلیفی می ماند و سیستم عامل کلاینت و یا سرور و یا هر دو، مدام retransmission انجام می دهند اما جوابی دریافت نمی کنند.\n(طراحی شده با draw.io)\nبه جای این کار سیستم سانسور می تواند packet ای با Flag ای شامل RST ارسال کند و یا RST را در packet ای که از سمت سرور ارسال می شود تزریق کند اما این کار را نمی کند. این روش دو سود برای سیستم سانسور دارد: اول اینکه زمان بیشتری از کاربران اینترنت هدر می دهد و کاربران را بیشتر منتظر می گذارد. دوم اینکه این سانسور بالاتر از سطح ISP انجام می شود و این retransmission ها که معمولا packet ای با حجم قابل توجه ای هستند، در تعداد زیاد و مداوم، برای ISP ها سودآور خواهند بود. هر دو از نظر اخلاقی، همانند وضع سانسور فعلی، درست نیستند، اما متاسفانه واقعیت دارند.\nسیستم سانسور جمهوری اسلامی # سیستم سانسورِ حاضر در اینترنت ایران، به نام سیستم سانسور جمهوری اسلامی بیان شده. به دلیل اینکه تمام مردم ایران برای رد شدن از آن هزینه می کنند، اما تمام سازمان های وابسته به جمهوری اسلامی در توسعه و تداوم آن مشارکت دارند. در نتیجه این سیستم سانسور «ایران» نیست و حتی «برای مردم ایران» نیست بلکه «بر ضد مردم ایران» است. حتی طبق داده های یکی از VPN های معروف که به صورت جهانی سرویس ارائه می دهد، حدود 400 هزار نفر روزه داران ایرانی که امسال (1400) برای سحر بیدار می شدند و از این VPN استفاده می کردند، بعد از وصل شدن به اینترنت، این VPN را نیز فعال می کردند.\nبا توجه به این مسئله که این آمار فقط مربوط به یک VPN از بسیار فیلترشکن موجود است، به وضوح نشان می دهد که اکثریت مردم مذهبی و غیرمذهبی ایران، با سانسور اینترنت مخالف هستند.\nنکات # اکثر دستورات در لینوکس استفاده شدند. اما معادل هایی برای ویندوز نیز در صورت وجود معرفی شده است.\nتوجه: اگر در شبکه های اجتماعی به صورت ناشناس فعالیت می کنید، نتیجه ی بعضی از این آزمایشات ممکن است موجب افشا شدن هویت واقعی شما شود. همچنین در سانسور مشخصات یکتای خود کوشا باشید. امنیت سایبری شما و اطرافیانتان به آنها بستگی دارد.\n"},{"id":1,"href":"/fa/docs/measure-internet-censorship/Application/find-l7-middleboxes/","title":"یافتن سیستم سانسور کننده در لایه ی کاربرد","section":"بررسی سانسور در ارتباط با سرور در لایه‌ی کاربرد","content":" یافتن سیستم سانسور کننده در لایه ی کاربرد # در بخش « بررسی سانسور در ارتباط در لایه ی کاربرد» در مورد روش های مقدماتی شناسایی سانسور در این لایه صحبت شد، اما همیشه سانسور به این سادگی قابل شناسایی نیست. مخصوصا زمانی که خود پروتکل هایی مانند TLS، HTTP و یا SSH در IP مورد هدف قرار گرفته شده باشد، نه مقدار hostname یا چیزی دیگر درون این packet ها.\nرفتار ها:\nخطای timeout به سمت یک IP ی مشخص بعد از ارسال TCP یا UDP ی دارای payload فقط drop شدن یکسری packet های خاص، مانند Server Hello و FIN و پاسخ با ACK قطع شدن ارتباط بعد از مدتی. مانند SSH بعد از حدود 15 تا 60 ثانیه در این حالت، انجام trace route های سنتی به تنهایی، بی معنی است و به چیزی نخواهید رسید. چرا که این نوع سانسورها بعد از TCP handshake و یا با تاخیر رخ می دهند. برای بررسی درست، دو راه دارید:\nیافتن fingerprint سیستم سانسور در پاسخ ها انجام application traceroute در ادامه این موارد را توضیح می دهیم و بعد در مورد شناسایی موقعیت سیستم های سانسور در مسیر ارتباط را بیشتر توضیح می دهیم. مانند انسداد متناوب اینستاگرام و مسدود کردن کروم به سمت آمازون از طریق TLS fingerprint. همچنین به سانسورهای امنیتی سایت های میزبانی شده در داخل و خارج، همانند کلاب‌هاوس اشاره می کنیم.\nیافتن fingerprint سیستم سانسور در پاسخ ها # تمام middlebox ها به دلیل اینکه سعی در جعل هویت سرور را دارند تا توسط برنامه ها در client مورد پذیرش قرار بگیرند، خصوصیاتی دارند که در حالی که حتی random به نظر می رسند، از الگوی مشخص پیروی میکنند که میتوان آنرا اثر انگشت سیستم سانسور کننده قلمداد کرد. در این مطلب، به این رفتارها و الگوهای قابل سنجش fingerprint، می گوییم.\nدر چین fingerprint سه دستگاه مختلف سانسور در مقاله ای مرتبط با DNS، به ثبت رسیده است. با کمک این مقاله و مقاله های مشابه، می توانیم در تمام کشورهایی که تجهیزات مدیریت، نظارت و سانسور حکومت چین در آنها نصب شده است، سانسورها در شبکه را از طریق یافتن چنین fingerprint هایی، شناسایی کنیم.\nبرای ساده سازی فقط یک مورد از fingerprint ها را در ادامه توضیح می دهیم و اگر نیاز بود، به مرور این بخش بروزرسانی خواهد شد.\nشناسایی از طریق IP.ID # برای شناسایی دستی از طریق IP.ID، نیاز به نصب Wireshark دارید. آموزش wireshark در اینترنت بسیار وجود دارد، در نتیجه در ادامه در نظر میگیریم که شما اطلاعات اولیه در مورد انتخاب شبکه و شروع capture کردن را دارید. و به طریق زیر می توانید IP.ID را به لیست ستون های wireshark اضافه کنید تا راحت تر بتوانید کار شناسایی را انجام دهید:\nدر ابتدا،‌ طبق مقاله، DNS را بررسی می کنیم.\nبه دلیل مجاز بودن درخواست اول، در پاسخ ما IP ی درست دریافت کردیم و مقدار IP.ID نیز random است. اما در درخواست دوم، یک سایت مسدود شده را تست کردیم و در پاسخ، IP های سیستم فیلترینگ جمهوری اسلامی را دریافت کردیم. مقدار IP.ID (ستون Identification) در اینجا تکرار IP.ID ی packet ای است که از کلاینت فرستاده است. این یعنی، طبق مقاله، سیستم سانسور در بعضی موارد، مقادیر را فقط انعکاس می دهد.\nحال، به جای DNS درخواست های HTTP را تست می کنیم. جایی که به جای UDP از TCP استفاده می کنیم اما همچنان می توانیم محتوایی مربوط به سیستم سانسور جمهوری اسلامی را دریافت کنیم. (در صورت ای که در شبکه PEP یا cache proxy پیاده سازی نشده باشد.)\nدر این مورد، ما امنیت بخش درخواست DNS را افزایش دادیم و در نتیجه، «شخص ناشناس» نمی تواند پاسخ DNS را دستکاری کند اما همچنان HTTP آسیب پذیر است. پاسخ درست دریافت شده و مقدار IP.ID نیز منعکس نشده.\nبه همین صورت، یک آدرس مسدود شده تست می کنیم:\nاما در درخواست یک سایت مسدود شده، که در پاسخ دریافتی، محتوای مربوط به سیستم سانسور جمهوری اسلامی در آن قرار دارد، می بینیم که مقدار IP.ID در پاسخ و در RST، انعکاسی از frame قبلی از درخواست کاربر است. و تمام packet های ارسالی بعدی، بدون پاسخ می مانند. که این یعنی وارد سیاهچاله شده اند.\nاگر درخواست را به این صورت تکرار کنیم، که از سرور example.com استفاده شود و اما مقدار Host برابر با reddit باشد، باز هم چنین رفتاری را مشاهده خواهیم کرد.\nبا این موارد، می توان مطمئن شد که رفتار سیستم سانسور نسبت به تمام پروتکل ها یکسان است.\nدر HTTPS معمولا روش هایی مثل null routing و RST injection شناخته شده است. اما روش های دیگری نیز وجود دارند. در ادامه روشی را توضیح می دهیم که چند سالی است که توسط جمهوری اسلامی به سایت های زیادی اعمال می شود.\nبه عنوان مثال سایت stackexchange.com سالهاست که با این روش عموما ناشناخته مسدود شده است:\nدر این نوع سانسور، شما در DNS مشکلی نمی بینید:\nخود آدرس هم مشکلی ندارد:\n(این تست با IP ی سایت example.com است اما از stackexchange.com در SNI استفاده می شود. توضیحات بیشتر در مورد این تکنیک را در بخش « بررسی سانسور در ارتباط با سرور در لایه ی کاربرد» می توانید بخوانید.)\nاما درخواست مستقیم با خطا مواجه می شود:\nدر اینجا می بینیم که به ظاهر یک packet به با مشخصه ی PSH,ACK از سرور ارسال شده اما اگر به مقدار IP.ID دقت کنیم، همانند سانسورهای قبلی، انعکاسی از IP.ID ی packet ارسالی از سمت کلاینت است. همچنین بعد از آن هیچ پاسخی دریافتی نمی شود. در حقیقت وارد سیاهچاله می شود.\nدر نتیجه، با توجه به به مقاله ای که در ابتدا به آن اشاره شد و این توضیحات گام به گام، این packet از سمت سیستم سانسور جمهوری اسلامی ارسال شده است، نه سرور. و این fingerprint ای از تجهیزات نظارت و سانسور چین است.\nاگر برعکس دو تست قبلی، از IP ی stackexchange.com استفاده کنیم و مقدار SNI را example.com قرار دهیم، باز هم این خطا را مشاهده خواهیم کرد:\nمی توان نتیجه گرفت که در این نوع سانسور،‌ خود IP مورد هدف قرار می گیرد، و تعداد وبسایت ها و سرویس های بسیار بیشتری تحت تاثیر این نوع سانسور قرار خواهند گرفت.\nاما در این نوع بخصوص از سانسور، سیاهچاله هدف اصلی نیست و سیستم سانسور جمهوری اسلامی در تلاش است تا کاربران را در استفاده از سرویس های خارجی، در مدت طولانی معطل کند:\nدر این تصویر با توجه به مقادیر IP.ID می بینید که سیستم سانسور packet های سمت کلاینت و سرور را در میانه ی یک stream/session مسدود یا drop می کند و خودش با کلاینت شروع به ارتباط می کند.\nبه دلیل اینکه:\nکلاینت در انتظار دریافت دیتا از سرور است؛ معمولا timeout خاصی در نرم افزار های کلاینت برای قطع ارتباط در زمان read bytes وجود ندارد، تا در شرایط سرعت پایین هم نرم افزار به کارکرد خودش ادامه دهد؛ وجود پاسخ هایی جعلی ACK از سمت سیستم سانسور برای فعال نگه داشتن اتصال ای که هیچ داده ای رد و بدل نمی شود و جلوگیری از بسته شدنش اش توسط سیستم عاملِ کلاینت، ارتباط تا مدت طولانی و نامشخصی ادامه پیدا خواهد کرد.\nدر بعضی موارد نیز، بعد از چند ثانیه یا دقیقه ارتباط مسدود می شود. به عنوان مثال، در اینجا SSH بعد از 33 ثانیه مسدود و وارد سیاهچاله شد:\nمقدار IP.ID در ردیف های 316 و 317 که از سمت سرور ارسال شده اند (source port: 22)، برابر با مقدار IP.ID ای است در ردیف 314 قرار دارد و از سمت کلاینت ارسال شده است. (source port: 47696) درنتیجه این دو packet از سمت سیستم سانسور ارسال شده اند، نه سرور.\nانجام application traceroute # همانطور که در ابتدا اشاره شد، شناسایی و یافتن منشا سانسورهایی که در لایه ی کاربرد انجام می شوند،‌ از طریق ابزار های trace route سنتی و ping ممکن نیست. هرچند، داشتن داده هایی بیشتر از مسیر شبکه، بسیار کمک کننده است.\nیک روش از شناسایی، در بخش « یافتن دستگاه دستکاری کننده ی DNS»‌ توضیح داده شد. جایی که از یک packet درست و کامل DNS استفاده می شود با query های مختلف.\nاما با توجه به وسعت زیادی پروتکل ها، رمزنگاری ها و تکنیک ها، ساختن هر packet از طریق یک نرم افزار، امکان پذیر نیست. حتی در TLS به دلیل مسدود سازی ها از طریق TLS fingerprint، ساخت یک packet ثابت راهکار خوبی برای شناسایی سانسور در لایه ی کاربرد نیست.\nبرای حل این موضوع،‌ در TraceVis این امکان اضافه شد تا کاربران بتوانند packet های مورد نظر خودشان را به این ابزار بدهند و در صورت نیاز، TCP handshake نیز انجام دهند. و یا در صورت نیاز، تنها packet ای را که در حال retransmit است را با همان مشخصات اصلی trace route کنند. مانند مورد SSH که بعد از 33 ثانیه ارتباط قطع شده بود.\nدر بخش های مختلف و به ترتیب، روش ها و نکات استفاده، توضیح داده خواهد شد:\nنصب و اجرا کپی کردن یک packet از Wireshark استفاده از file های config انجام trace route بعد از مشاهده ی وارد سیاه چاله شدن تکنیک paris traceroute توضیحات بیشتر شناسایی پاسخ middlebox از طریق fingerprint آنها به صورت اتوماتیک توسط TraceVis در زمان packet injection گسترده:\n(علامت ستاره به معنای پاسخ از سیستم سانسور است و دایره های خاکستری به معنای عدم پاسخ در آن hop)\nدر زمان رفع شدن سانسور:\nنصب و اجرا # این ابزار در سیستم عامل های Linux, Windows, macOS تست شده. برای اجرا،‌ نیاز به داشتن Python نسخه ی 3 دارید. و در ویندوز، نیاز به نصب npcap که با نصب Wireshark، به صورت اتوماتیک نصب خواهد شد.\nدر لینوکس، نسخه کرنل قبل از 5 نیاز به نصب iptables نیز دارید.\nبعد از دانلود و یا clone کردن با git، قبل از استفاده باید از نیازمندی های برنامه، که scapy، pyvis و requests هستند را نصب کنید:\npython3 -m pip install -r requirements.txt یا با docker:\ndocker pull ghcr.io/wikicensorship/tracevis برای تست عملکرد درست برنامه، میتوانید تست عادی DNS را اجرا کنید:\npython3 ./tracevis.py --dns یا با docker:\ndocker run ghcr.io/wikicensorship/tracevis --dns اگر خطایی مشاهده نکردید و نتیجه درست بود، یعنی کار را به درستی انجام دادید و این ابزار آماده ی استفاده است.\nدریافت یک packet از Wireshark و استفاده در TraceVis # در بخش « یافتن دستگاه دستکاری کننده ی DNS»‌ توضیح داده شد که چطور در tcpdump مقدار hexdump از packet ها بعد از لایه ی IP را مشاهده کنید و به TraceVis بدهید. اما با Wireshark به دلیل گرافیکی بودن ابزار، دریافت packet درست، راحت تر است.\nدر آخرین نسخه از TraceVis این امکان فراهم شده است که هم packet کامل که از لایه ی Ethernet شروع شده است دریافت کند، و هم از لایه ی IP. بنابراین، یک packet به صورت زیر می تواند دریافت شود:\n(هر دو مورد Hex+ASCII Dump و Hex Dump برای TraceVis یکسان هستند)\nدر TraceVis دستور را به صورت زیر اجرا می کنید:\npython3 ./tracevis.py -p و مقدار کپی شده را paste می کنید:\nبعد از یک Enter مشخصات packet برای شما نمایش داده خواهد شد:\nاگر packet ای با flag های PSH,ACK را به TraceVis بدهید، مانند Client Hello و یا DNS over TCP، از شما سوال خواهد شد که آیا مایل به انجام TCP handshake قبل از ارسال این packet مورد نظر، هستید یا خیر. (نکته: در DNS over TCP نیاز به TCP handshake نیست اما همچنان PSH,ACK است. در نتیجه سوال می شود)\nدلیل انجام این کار این است که اگر در شبکه، تجهیزاتی مانند PEP وجود داشته باشد، از عبور packet هایی مانند Client Hello بدون TCP session فعال، جلوگیری خواهد کرد و نتیجه ای اشتباه خواهید داد. بنابراین، در TraceVis امکان انجام درست TCP handshake و بعد ارسال packet درخواستی کاربر با استفاده از TCP session به وجود آمده، فراهم شده است. (در برنامه، ساز و کاری برای مشاهده ی hop های بعد از PEP هم در نظر گرفته شده است)\nاگر در لینوکس در حال تست هستید، به شما اطلاع داده می شود که نیاز دارید تا این rule برای iptables را اضافه کنید، تا از ارسال packet های RST توسط سیستم عامل کلاینت جلوگیری شود. این کار فقط در kernel های قبل از 5 مورد نیاز است. و می توانید از TraceVis بخواهید که به صورت اتوماتیک این کار را برای شما انجام دهد. (اضافه و حذف بعد از پایان) اگر در حال تست در سیستم عامل دیگری هستید، سوال بعدی پرسیده می شود برای اضافه کردن packet دوم:\nکه دقیقا مراحل مثل قبل است. و بعد از اتمام تست شروع می شود.\nاستفاده از file های config # بعد از انجام هر تست توسط TraceVis یک فایل config نیز برای اجرای دوباره ی همان دستور بدون نیاز به طی کردن مراحل قبلی ساخته می شود. چند فایل نمونه هم در پوشه ی samples اضافه شده است. به عنوان مثال اگر میخواهید تست NTP انجام دهید:\npython3 ./tracevis.py --config ./samples/ntp.conf و اگر قصد تغییر مقصد پیشفرض را دارید، کافی است تا آدرس را اضافه کنید:\npython3 ./tracevis.py --config ./samples/ntp.conf -i “1.2.3.4” توجه داشته باشید که امکان تغییر مواردی مانند SNI از طریق خط فرمان فعلا میسر نیست، در نتیجه، اگر قصد تست وبسایت جدیدی را دارید، باید یک packet جدید برایش بسازید. چرا که، به عنوان مثال، فایل clienthello.conf در samples مقدار SNI اش آدرس instagram.com هست. و همچنین ممکن استTLS fingerprint قدیمی Chrome باشد و سانسور بر مبنای TLS fingerprint وجود داشته باشد.\nانجام trace route بعد از مشاهده ی وارد سیاهچاله شدن # در بخش قبلی در مورد SSH دیده بودید که بعد از 33 ثانیه، ارتباط وارد سیاهچاله شده بود، و در مواردی این حالت به صورت موقت وارد سیاهچاله می شد و دوباره ارتباط برقرار می شد. در این شرایط امکان شناسایی منشاء این مشکل از طریق شیوه های قبلی وجود ندارد، چرا که فعلا امکان پیاده سازی هر پروتکل به صورت مجزا ممکن نیست. برای شناسایی منشاء این مشکل در این حالت، فقط کافی است که یکی از packet هایی که در حال retransmission هستند را کپی کنیم:\nو به صورت زیر به برنامه بدهیم:\npython3 ./tracevis.py --rexmit بعد از زدن کلید Enter، تست شروع می شود و سه بار تکرار می شود. در این حالت، TraceVis مقادیر five-tuple را حفظ می کند و همگام با افزایش TTL از 1، مقدار IP.ID این packet را نیز یک مرتبه افزایش می دهد. این حالت شبیه به یک retransmission واقعی است، اما در عین حال، می توانیم متوجه شویم که از چه بخشی از مسیر ارتباط null route می شود.\nتکنیک paris # تکنیک Paris یا Paris Traceroute به روشی که گفته می شود که در آن five-tuple هر packet در هر مرحله حفظ می شود تا هر بار در شبکه، از یک مسیر یکسان عبور کند.\nاین روش، از دیدن loop اشتباه در شبکه جلوگیری می کند.\nکه در صورت استفاده از تکنیک paris، به این صورت خواهد بود:\nدر اینجا مشاهده می کنید که که در ابتدای مسیر، تعداد hop های مسیر سمت چپ کمتر از مسیر سمت راست است. این حالت باعث شده بود که در حالت غیر paris،‌ تعداد زیادی حلقه مشاهده کنیم.\nهرچند همانطور که در بخش « بررسی سانسور در ارتباط با سرور در لایه‌ی شبکه و انتقال» گفته شد، ممکن است حتی با تکنیک paris هم این حلقه ها را مشاهده کنید. در این صورت، می تواند نشانی از walled garden باشد برای ایزوله کردن ارتباط داخل و خارج شبکه.\nنکته ی مهم:‌ اما اگر از این روش برای حالتی استفاده می کنید که از قبل نیاز به TCP handshake دارد،‌ ممکن است نتیجه ای که مشاهده می کنید با خطا مواجه شود. به دلیل اینکه: ابتدا با سرور اتصال برقرار می شود و TCP session فعال به وجود می آید بعضی سرور ها در مدت کمی بعد از ایجاد TCP session، و در صورت دیافت نکردن packet، اقدام به بستن ارتباط با استفاده از packet های FIN یا RST می کنند. که این خود نکاتی دارد: سیستم سانسور نیز ممکن است اقدام به ارسال این packet ها کند که در بعضی شرایط میتوان از طریق fingerprint سیستم سانسور تفاوت را تشخیص داد. اگر در شبکه PEP وجود داشته باشد و بعضی middlebox ها، بعد از مشاهده ی این packet ها از ادامه ی ارتباط جلوگیری می کنند. و باعث اشتباه در نتیجه خواهند شد، در نتیجه نمیتوان وجود آنها را نادیده گرفت.\nبه دلیل اینکه در این حالت، مقدار five-tuple یکسان هستند، و همچنین اعمال سانسور، سیاهچاله یا packet injection، ممکن است با تاخیر همراه شود، نمیتوان با سرعت زیادی و یا به صورت همزمان با TTL های مختلف تست انجام داد.\nهرچند در تلاش هستیم که هر روز بهینه سازی هایی انجام دهیم و راهکار های زیادی می توان در نظر گرفت.\nیکی از موارد خوب در استفاده از این روش، در حالتی که سرور سریعا ارتباط را قطع نکند، تشخیص انسداد متناوب است. در این حالت، چند اتصال مجاز به عبور و چند اتصال مسدود می شوند. به طور مثال، آدرس مربوط به بخش دایرکت اینستاگرام را به صورت زیر تست می کنیم:\npython3 ./tracevis.py -p -m 30 --paris -r 9 حداکثر تعداد 30 hop و تعداد تکرار 9 بار. و packet مورد نظر داده می شود و درخواست TCP handshake هم می شود. به همراه تکنیک paris، یعنی 9 مورد five-tuple مختلف.\nدر این تصویر تست فقط جریان های 1،3،7،9 با موفقیت به مقصد رسیدند. دیگر موارد در داخل قبل از خروج از کشور و با چقدر تلاش، از عبور آنها جلوگیری شد.\nبه صورت مشابه میتوان تست DNS نیز برای شناسایی موقعیت سیستم سانسور انجام داد:\nدقیقا در موقعیتی که پاسخی در جریان های مربوط به اینستاگرام دریافت نشد،\nبه آدرس های سانسور شده در DNS واکنش نشان داده می شود:\n( مکان اصلی این سیستم سانسور: بعد از 10.21.249.201)\nتوضیحات بیشتر # روش های و امکانات زیادی در TraceVis قرار داده شده است که میتوانید از آنها بهره ببرید. مانند اضافه کردن پیشوند برای فایل های نتایج. اضافه کردن یادداشت به هر نتیجه ی مستقل با یک packet. و یا دیدن نتایج به صورت جدولی در یک فایل CSV.\nهم اکنون این ابزار در حال استفاده و قابلیت استفاده ی گسترده را دارد. اما فعلا بهتر است توسط افرادی که از شبکه اطلاع دارند و این مطلب را خوانده اند تحلیل و بررسی شود.\nدر تلاشیم تا قبل از نسخه ی اول، بهینه سازی های زیادی انجام دهیم و امکانات بیشتری اضافه کنیم.\nو همچنین تشخیص روش های سانسور را برای کاربران و خودمان راحت تر کنیم.\nبه عنوان مثال در شرایطی که حتی در TCP handshake هم سیستم سانسور خود را جای سرور قرار می دهد.\nدر اینجا می بینید که حتی IP.ID در SYN,ACK هم انعکاسی از IP.ID ی SYN است.\nسیستم سانسور در اینجا ارتباط را با SYN,ACK شروع کرده، با PSH,ACK پاسخ داده*، و با FIN,ACK ارتباط را پایان داده.\n[*] در اینجا، PSH,ACK دارای هیچ دیتایی نیست، اما مواردی با مقدار های زیر هم مشاهده شده است:\n\u0026#34;\\x30\\x32\\x30\\x30\\x30\\x30\u0026#34; \u0026#34;\\x6e\\x96\\x3f\\xa9\\xf8\\xdd\u0026#34; \u0026#34;\\xfe\\xb3\\x01\\xa0\\xbf\\xcb\u0026#34; بعد از به اصطلاح رفع شدن مشکل، اثری از پاسخ ها از سمت سیستم سانسور نیست اما کیفیت ارتباط به شدت پایین است:\nشناسایی موقعیت سیستم های سانسور دیگر در یک مسیر یکسان # در تکنیک paris موردی از سانسور متناوب اینستاگرام توضیح داده شده است. در ادامه دو مورد از سانسور دیگر توضیح می دهیم:\nسیستم سانسور TLS fingerprint سانسورهای امنیتی سیستم سانسور TLS fingerprint # در این نوع سانسور،‌ شما ممکن است با یک برنامه یا مرورگر به وبسایتی دسترسی داشته باشید اما با یک مرورگر دیگر این امکان وجود نداشته باشد.\nبه طور مثال، سایت آمازون با کروم:\n(آمازونِ چین جزو لیست سانسور نبوده)\nاما با فایرفاکس مشکلی وجود نداشته:\nاز طریق TraceVis یک تست اجرا می کنیم.\nیک Client Hello از Chrome را که آدرس example.com در SNI وجود دارد استفاده می کنیم. اما به مقصد یکی از IP های AWS که توسط سایت آمازون استفاده می شود:\npython3 ./tracevis.py -p --annot1 \u0026#34;example.com CH chrome\u0026#34; --paris -i \u0026#34;13.226.135.75\u0026#34; به همین صورت یک تست اما Client Hello از Firefox اجرا می کنیم. و در انتها دو نتیجه را با هم ترکیب می کنیم. به این صورت:\nPython3 ./tracevis.py -f “./path/to/file-firefox.json” -f “./path/to/file-chrome.json” نتیجه به این صورت خواهد بود:\nرنگ صورتی مربوط به chrome است و رنگ فیروزه ای مربوط به Firefox.\nهمانطور که می بینید،‌تمام درخواست ها بعد از 10.202.6.90 وارد سیاهچاله شده اند.\nبه دلیل Hijack شدن تمام درخواست های DNS، (همانطور که در بخش « یافتن دستگاه دستکاری کننده ی DNS» توضیح داده شد)، اگر تست DNS به سمت همین IP انجام دهیم:\npython ./tracevis.py --dns -i \u0026#34;13.226.135.75\u0026#34; -m 30 --paris که در اینجا به صورت اتوماتیک دو درخواست DNS برای آدرس های example.com که سانسور نیست، و twitter.com که سانسور است انجام می شود.\nرنگ صورتی آدرس twitter.com و رنگ فیروزه ای آدرس example.com است.\nتمام درخواست های مربوط به twitter.com بعد از 10.21.249.201 مسدود می شوند. (برخلاف مورد قبلی که بعد از 10.202.6.90 بود)\nسانسور در SNI نیز انجام می شود، چه تفاوتی ممکن است بین مسدود سازی از طریق TLS fingerprint و SNI وجود داشته باشد؟‌ برای پاسخ به این سوال، یک تست مربوط به SNI نیز به سمت همین مقصد مورد نظر، انجام می دهیم:\npython ./tracevis.py -p --annot1 \u0026#34;twitter.com chrome\u0026#34; -i \u0026#34;13.226.135.75\u0026#34; این بار از Client Hello ی کروم استفاده می کنیم اما به جاز آدرس مجاز example.com از آدرس twitter.com استفاده می کنیم.\nبا زوم بیشتر:\nهمانطور که می بینید، برخلاف مورد اول، قبل از اینکه به 10.202.6.90 برسد درخواست های بعدی وارد سیاهچاله شده است.\nاین نشان می دهد که که حتی ساختار شبکه هم شبیه به چین ساخته شده است.\nسانسورهای امنیتی # از «سانسورهای امنیتی»، در اینجا برای توضیح مواردی استفاده می کنیم که توسط سیستم های سانسور معمول انجام نمی شوند و معمولا شیوه ی سانسور آنها نیز متفاوت است و ممکن است فقط در یک شبکه و حتی یک middlebox مشاهده شوند (در صورت میزبانی شدن آن سرویس در داخل کشور). به عنوان مثال سانسور کلاب‌هاوس در همراه اول، در همان ابتدای شبکه انجام می شود:\nو حتی به سیستم سانسور معمول شبکه و یا سیستم های سانسور بعدی در زیرساخت نمی رسد. موقعیت های حدودی سیستم اصلی سانسور در همراه اول:\nدر «سانسورهای امنیتی»، شما فقط زمانی سانسور را مشاهده می کنید که مقدار SNI و IP ی درستی انتخاب کنید. اگر در SNI از example.com استفاده کنید و یا از یک IP ی متفاوت، سانسور را مشاهده نخواهید کرد. اما از طریق TraceVis می توانید متوجه شوید که در چه موقعیت ای از شبکه این سانسور انجام می شود.\n"},{"id":2,"href":"/fa/docs/measure-internet-censorship/OONI/","title":"بررسی سانسور اینترنت از طریق کاوشگر OONI","section":"بررسی سانسور اینترنت: مقدمه","content":" بررسی سانسور اینترنت از طریق کاوشگر OONI # OONI و یا Open Observatory of Network Interference، ترجمه شده به فارسی: «رصد خانه آزاد دخالت در شبکه»، یک پروژه ی نرم افزاری متن باز و آزاد با هدف توانمند سازی تلاش های غیرمتمرکز در افزایش شفافیت سانسور اینترنت در سراسر جهان است. OONI یک سَمَن یا سازمان غیردولتی است که توسط پروژه ی Tor راه اندازی شد و اکنون به صورت نیمه مستقل فعالیت می کند. این پروژه با ایجاد نرم افزارهایی برای سیستم عامل های مختلف این امکان را فراهم می کند که یک شخص بدون نیاز به دانش فنی، فقط با اجرا کردن تست ها، شواهدی معتبر از سانسور تهیه کند.\nبه صورت پیشفرض این اطلاعات با حفظ حریم خصوصی کاربران، برای سرور OONI ارسال می شوند. اطلاعات دریافتی در سرور دوباره پردازش می شوند و در اکثر مواقع در کمتر از یک دقیقه در بخشی به نام Explorer تحت وب در دسترس همگان خواهد بود.\nاز سال 2012 تاکنون از بیش از 200 کشور نتایج اندازه گیری دریافت کرده.\nچگونگی کارکرد تست Websites # در Probe های OONI بخشی به نام Websites وجود دارد که در حال حاضر می تواند آدرس های http:// و https:// را مورد آزمایش قرار دهد. این تست که با اسم Web connectivity شناخته می شود به این صورت کار می کند که ابتدا یک بار آدرس درخواستی را از طریق backend خود مورد آزمایش قرار می دهد تا از فعال بودن آن اطمینان حاصل کند و همچنین جواب DNS و محتوای دریافتی در backend را با DNS و محتوای دریافتی در شبکه ی مورد تست مقایسه کند. به این معنی که اگر پاسخ تست ای، Anomaly و یا Confirmed بوده است، تست در backend و خارج از شبکه در همان لحظه با موفقیت انجام شده است. این مسئله صحت نتیجه در مورد وجود سانسور را تضمین می کند.\nبه صورت پیشفرض این تست از لیست آدرس هایی استفاده می کند که توسط CitizenLab ساخته شده و هر کسی میتواند در بهبود آن مشارکت داشته باشد. در هر کشور دو لیست مورد استفاده قرار میگیرد که یک لیست اختصاصی آن کشور و یک لیست جهانی است. در زمان نوشتن این مقاله این دو لیست شامل 2242 آدرس است.\nباید توجه داشته باشید که این لیست سایت هایی نیست که احتمال سانسور شدن آنها زیاد است. می توان گفت که این لیست ای از سرویس های پر استفاده است. اما نه لیست ای که توسط سرویس هایی مانند Alexa معرفی می شود، چون در بسیاری از کشور ها، مردم از ابزار های حفظ حریم خصوصی همانند VPN ها استفاده می کنند و یا در کشورهایی مثل ایران، اکثر سرویس های پراستفاده ی مردم، مسدود یا تحریم هستند و کاربر نمی تواند به صورت مستقیم به آنها دسترسی پیدا کند.\nتست های پیشفرض در این بخش، به صورت پیشفرض فقط 90 ثانیه اجرا می شوند که از بخش تنظیمات این مقدار قابل تغییر است.\nمقدار 0 برابر با انجام اندازه گیری تمام آدرس های لیست پیشفرض است.\nالبته این امکان وجود دارد تا آدرس ها و یا آدرس های سفارشی خودتان را نیز بدون نیاز به ثبت در لیست پیشفرض در شبکه ی خود و یا دوستانتان تست کنید. برای این کار دو روش وجود دارد:\nوارد کردن مستقیم لیست در اپ ها ایجاد لیست تست سفارشی وارد کردن مستقیم آدرس های سفارشی در نرم افزار # برای انجام این کار به صورت درون برنامه ای، وارد بخش Websites شوید و بر روی دکمه ی Choose websites و یا «انتخاب وبسایت ها» کلیک کنید :\nآدرس های مورد نظر خود را وارد کنید. و در انتها دکمه ی Run در پایین صفحه را بزنید. و در انتها بر روی دکمه ی Run و یا اجرا کلیک کنید تا اندازه گیری آغاز شود.\nدر نسخه ی cli، برای دفعه ی اول، ابتدا باید شرایط استفاده را بخوانید و در صورت موافقت، تایید کنید:\n\u0026gt; .\\ooniprobe.exe\nسپس لیست انتخابی خود را به این صورت اجرا کنید:\n\u0026gt; .\\ooniprobe.exe run websites --input=https://yahoo.com/ --input=https://yimg.com/\nدر این حالت نتیجه ی هر تست و تفاوت ها به صورت لحظه ای نشان داده می شود.\nایجاد لیست تست سفارشی # برای اینکه یک لیست سفارشی داشته باشید که بتوانید با دیگران به اشتراک بگذارید، می توانید به این آدرس رجوع کرده: https://run.ooni.io/\nبعد از اضافه کردن آدرس های دلخواه از طریق دکمه ی Add URL دکمه ی Generate را بزنید.\nآدرس داده شده را کپی کرده و از طریق شبکه های اجتماعی برای دیگران بفرستید.\nکاربران در موبایل می توانند فقط با زدن بر روی لینک، اپ OONI Probe را انتخاب کرده:\nو با زدن دکمه ی Run اندازه گیری را شروع کنند.\nآنالیز نتایج # آنالیز نتایج OONI بسیار ساده و آسان است. شما نیاز به داشتن دانش فنی برای درک وجود سانسور یا نبود آن ندارید. به عنوان مثال در این تصویر:\nاز 7 مورد آزمایش شده، دو مورد را با اطمینان می توان گفت که ارتباطشان به دلیلی در آن لحظه مسدود شده است و چهار مورد در دسترس بودند.\nهمچنین یک مورد با رنگ خاکستری است که سه دلیل شایع می تواند داشته باشد:\nغیرفعال بودن سایت مورد تست قطع شدن لحظه ای اینترنت کاربر در زمان انجام آن تست وجود باگ یا ناتوانی در تحلیل توضیحات آن نیز به این صورت است که علاوه بر مشاهده ی توضیحات بیشتر می توانید با زدن بر روی دکمه ی Try Again، دوباره اقدام به تست آن یک آدرس کنید:\nآنالیز ساده ی نتایج # برای بررسی دقیقتر، در توضیحات هر نتیجه، دلیل آنها بیان شده است. چند مورد را که ممکن است بیشتر با آنها مواجه شوید در ادامه توضیح داده خواهد شد.\nHTTP blocking (a blockpage might be served) # در این تست احتمال می رود که ممکن است صفحه ی مربوط به سانسور به جای صفحه ی اصلی دریافت شده باشد. این اتفاق فقط در ارتباط های غیر رمزنگاری شده و مخصوصا HTTP ممکن است. در این حالت چهار دلیل ممکن است:\nدریافت خطای 503، که خود نوعی سانسور است (در بخشی های بعدی توضیح داده خواهد شد) حساسیت به آدرس سایت در بخش Host ارتباط HTTP حساسیت به Request URI یا همان ادامه ی آدرس بعد از Hostname. (در این تست فقط / هست و حاوی path نیست.) حساسیت به یک کلمه در محتوای آن سایت. DNS tampering # در این تست احتمال می رود که یک IP ی جعلی دریافت شده است. در این حالت، این ارتباط از طریق دستکاری DNS مسدود شده است.\nTCP/IP based blocking # در این تست، عمل TCP Handshake انجام نشده. که ممکن است به دلیل وارد سیاهچاله شدن ارتباط باشد و یا ارسال packet های RST از سوی سیستم سانسور. در این حالت، IP مسدود شده است.\nHTTP blocking (HTTP requests failed) # در این تست TCP Hnadshake انجام شده است (IP مسدود نیست) اما بعد از آن ناموفق بوده است. این خطا ممکن است در هر دو ارتباط HTTP و HTTPS مشاهده شود. (در نسخه ی فعلی)\nآنالیز پیشرفته ی نتایج # برای آنالیز پیشرفته تر، در نرم افزار های OONI این امکان وجود دارد تا دیتای جمع آوری شده از هر تست را ببینید.\nاین دیتا از طریق آدرس اختصاصی Explorer نیز در دسترس است.\nدر این دیتا، اطلاعات کلی و جزئیِ هر اندازه گیری به صورت مجزا وجود دارد.\nتوضیح بعضی از بخش ها:\nprobe_ip # مقدار probe_ip که برابر با IP کاربر است. برای حفظ حریم خصوصی، به صورت پیشفرض در سمت کلاینت به 127.0.0.1 تغییر داده می شود.\nresolver_ip # مقدار resolver_ip برابر IP سرور ای است که کاربر احتمالا* در این تست از آن استفاده کرده است. این مقدار با درخواست DNS مستقل به آدرس whoami.akamai.net محاسبه می شود. به صورت زیر:\nطراحی شده با draw.io\n[*] به دلیل مستقل بودن هر درخواست، در برخی شبکه ها و در بعضی شرایط، ممکن است که دو درخواست، از دو DNS سرور متفاوت درخواست شوند. اگر:\nکاربر در تنظیمات DNS خودش، سرور دوم را از یک سرویس دهنده ی متفاوت استفاده کند. اگر ISP به صورت random از سرور های متفاوتی برای resolve کردن استفاده کند. (به عنوان مثال: DNS پیشفرض همراه اول) test_keys # دیتای اصلی هر تست، در بخش test_keys قرار دارد:\nتوضیحات در مورد زیرمجموعه های test_keys:\nnetwork_events # بخش network_events شامل رویداد های ارتباطی مابین کلاینت و سرور است. ساده تر از چیزی که با capture کردن packet ها به دست می آوریم. برای اینکه ببینیم که مسدود شدن بعد از Client hello بوده است و یا بعد از TLS handshake.\nدر اینجا زمانی که TLS handshake شروع شد و write انجام داده است (معادل Client hello)، جواب دریافتی reset بود. (معادل packet های RST یا RST,ACK). بدان معنی که سیستم سانسور با مواجه شدن مقدار SNI در Client Hello، از ادامه ی ارتباط جلوگیری کرده است.\ntls_handshakes # بخش tls_handshakes شامل certificate هایی است که در هر بار request از سرور دریافت می شود. (در Server Hello)\nدر صورت حمله ی MITM این دیتا بسیار مفید خواهد بود. و در صورت خطا در زمان TLS handshake، توضیح آن بیان می شود:\nqueries # بخش queries شامل درخواست های DNS و جواب های دریافت شده می شود:\nهمچنین در این بخش، در همان لحظه، IP های دریافتی بررسی می شوند که متعلق به کدام شبکه هستند.\ndns_consistency # بخش dns_consistency مربوط می شود به یکسان بودن و یا نبودن جواب DNS در تست انجام شده در سرور OONI و در این شبکه ی فعلی در همان لحظه.\ncontrol # بخش control مربوط می شود به تست های انجام شده در سرور OONI که همزمان صورت می گیرد.\n(در مورد موارد درون این بخش در ادامه توضیح داده نخواهد شد. به دلیل تکراری بودن با مواردی که در خود شبکه در حال تست است. و همچنین نبود سانسور در این شبکه ی سرور OONI.)\ntcp_connect # بخش tcp_connect مربوط می شود به تست TCP handshake تمام IP هایی که از درخواست DNS به دست آمد.\nrequests # بخش requests مربوط می شود به درخواست ها و جواب هایی که در سطح HTTP انجام می شوند.\nدر اینجا از ادامه ی ارتباط جلوگیری شده. به این معنی که احتمالا سیستم سانسور بعد از مشاهده ی مقدار Host در packet ارسالی یک packet با پرچم حاوی RST برای کاربر ارسال کرده است.\nدر اینجا جوابی با iframe از صفحه ی سیستم سانسور جمهوری اسلامی بازگردانده/تزریق شده.\nموارد بیشتر # بخش های دیگر نیز نسبت به HTTP و یا HTTPS بودن ارتباط متفاوت است.\nبه عنوان مثال، در اینجا نشان می دهد که تبادل HTTP در HTTPS به درستی انجام نشده است:\nو یا مقادیر دو تست درون و بیرون شبکه در ارتباط HTTP یکسان نیست:\nتشخیص تحریم # یکی از سوال های مهم که در هر بار عدم دسترسی به سرویس ای یک ایرانی از خودش می پرسد این است که «آیا این سایت فیلتر شده و یا تحریم؟» برای پاسخ به این سوال نیز می توان از OONI کمک گرفت. چرا که علاوه بر اینکه موارد زیادی را آنالیز می کند، همزمان هم در شبکه ی فعلی و هم از طریق سرور backend، اتصال به آدرس مورد نظر را بررسی و مقایسه می کند.\nاگر آدرس وارد شده HTTPS باشد، به دلیل اینکه توسط شخص ناشناس قابل دستکاری نیست، نتیجه قابل اعتمادتر خواهد بود. در ادامه یک آدرسی را که به دلیل استفاده از کلاد گوگل در ایران قابل استفاده نیست را به صورت نمونه بررسی می کنیم.\nدر نتیجه ی آنالیز می بینیم که به رنگ سبز است و این یعنی مشکلی در ارتباط وجود ندارد.\nدر بخش Failure نیز می بینیم که تمام آنها null هستند و این یعنی هیچ دستکاری ای در شبکه انجام نشده است.\nدر بخش داده ها و در زیرمجموعه ی control می بنیم که مقدار عنوان درست است و همینطور کد دریافتی برابر با 200 است. که این یعنی سرور سایت به شبکه ای دیگر در خارج از کشور به درستی جواب می دهد.\nاما در بخش requests کد دریافتی و همچنین response دارای مقدار متفاوتی است.\nکد 403 و گاهی کد 404 اگر در این شرایط گفته شده (ارتباط HTTPS و متفاوت با نتیجه ی خارج از کشور) باشد، به معنای تحریم است.\nهمچنین در انتهای بخش test_keys مقایسه هایی صورت میگیرد که نتیجه ی کلی از تمام موارد گفته شده در بالا را نشان می دهد.\nذکر این نکته مهم است که طی یک سال اخیر مورد ای از تحریم مشاهده نشده که بدون نمایش خطای 403 و یا 404 در ارتباط HTTPS از درخواست ها به دلیل تحریم جلوگیری کنند. در نتیجه اگر نتیجه غیر از سبز بود، احتمالا سایت به طریقی در شبکه ی شما سانسور شده است.\nتنظیم داخلی فیلترشکن فقط برای ارتباط با backend # به دلیل سانسور های دسته ای سرویس ها در ایران و بدون در نظر گرفتن عواقب آن و زیر پا گذاشتن حق‌الناس توسط حکومتی که مدعی آن است، ارتباط با سرور OONI در موبایل، به دلیلی که در بخش «شناسایی مسدود شدن از طریق fingerprint» توضیح داده شد، امکان پذیر نیست.\nبرای حل این مشکل، تیم OONI دو تغییر مهم ایجاد کردند:\nتغییر TLS fingerprint برای تقلید fingerprint مرورگر اضافه کردن بخش Proxy برای ارتباط با backend برای فعال کردن proxy، به بخش تنظیمات رفته و OONI backend Proxy را انتخاب می کنیم:\nدر این بخش (در زمان نوشتن این مقاله) سه گزینه ی اصلی داریم: از هیچ proxy ای استفاده نشود از Psiphon استفاده شود از یک Proxy شخصی استفاده شود. (در حال حاضر فقط SOCKS5)\nتنظیماتی که در تصویر می بینید (127.0.0.1:9050) متعلق به SOCKS5 ای است که توسط Orbot ایجاد می شود.\nتوجه داشته باشید که برای استفاده از OONI، نباید حالت VPN فعال باشد. اگر از Tor Browser استفاده می کنید، port آن برای SOCKS5 برابر با 9150 است.\nبعد از فعال کردن یکی از این گزینه ها. ارتباط با backend توسط آن proxy صورت می گیرد اما تست ها از طریق خود شبکه:\nدر تصویر می بینید که ابتدا به Psiphon متصل می شود.\nاما تست ها از طریق شبکه ی کاربر انجام می شود.\nداده کاوی در داده های نتایج OONI # اگر قصد دارید که نتایج OONI را بیشتر از چیزی که در Explorer مشاهده می کنید، بررسی و آنالیز کنید، این امکان فراهم است تا بتوانید تمام داده ها را از سرویس عمومی S3 آمازون مخصوص OONI به صورت دسته بندی شده به تاریخ، کشور، نوع تست و ساعت دریافت کنید.\nبه عنوان مثال در ادامه، تمام نتایج مربوط به تست webconnectivity را از طریق ابزار aws cli دانلود می کنیم:\naws --no-sign-request s3 sync --exclude \u0026#39;*\u0026#39; --include \u0026#39;*/IR/webconnectivity/*.jsonl.gz\u0026#39; \u0026#39;s3://ooni-data-eu-fra/raw/\u0026#39; ./ooni-data-iran حجم این نتایج برای هر روز متغیر است:\ndu -h --max-depth=0 ./ooni-data-iran/202106* و بیشترین اندازه را در روز می توان نزدیک به 150 مگابایت در نظر گرفت.\ndu -h --max-depth=1 ./ooni-data-iran | sort -hr البته داده این داده ها فقط مربوط به تست webconnectivity بودند.\nبرای دانلود تمام نتایج، به عنوان مثال در روز 22 ماه May به این صورت عمل می کنیم:\naws --no-sign-request s3 sync --exclude \u0026#39;*\u0026#39; --include \u0026#39;*/IR/*.jsonl.gz\u0026#39; \u0026#39;s3://ooni-data-eu-fra/raw/20210522\u0026#39; ./ooni-data-iran که کل حجم آن برابر است با 137 مگابایت.\n$ du -sch 137M . 137M total این فایل ها با نسبت حدود 80٪ فشرده سازی شده اند.\n$ gzip -l * compressed uncompressed ratio uncompressed_name 2277712 12444162 81.7% ./2021052222_IR_webconnectivity.n0.0.jsonl به عنوان مثال یک فایل حدود 2 مگابایتی، بعد از decompress کردن حدود 12 مگابایت فضا را اشغال خواهد کرد.\n$ ls -shi total 15M 1082 12M 2021052222_IR_webconnectivity.n0.0.jsonl 1071 2.2M 2021052222_IR_webconnectivity.n0.0.jsonl.gz در این فایل ها، هر خط جدید شامل یک نتیجه ی مجزا می شود:\nیک طرح ساده از مورد استفاده شده از داده های NDT ی OONI را می توانید در اینجا ببینید:\nبرای دریافت توضیحات بیشتر در این رابطه، می توانید متن OONI در مورد داده کاوی نتایج را مطالعه کنید.\n"},{"id":3,"href":"/fa/docs/measure-internet-censorship/DNS/find-DNS-hijacker/","title":"یافتن دستگاه سانسور کننده ی DNS","section":"بررسی سانسور اینترنت در ارتباط DNS","content":" یافتن دستگاه دستکاری کننده ی DNS # به دلیل عدم شفافیت ISP ها و حکومت در اعمال سانسور و نبود حد و مرز در آن، نیاز است تا دریابیم که چه کسی مسئول یک اختلال و سانسور است. همچنین این بخش مقدمه ای برای بررسی بیشتر و اثبات رفتار سیستم سانسور در مسدود کردن برخی ارتباطات است که در بخش «سانسور random» آن را بررسی خواهیم کرد.\nاگر از DNS ارایه شده توسط ISP استفاده می کنید احتمالا به صورت پیشفرض این خود ISP است که دارد جواب DNS را دستکاری می کند. اما در مورد DNS های دیگر و بخصوص موارد خارج از ایران، بررسی هایی می توان انجام داد.\nشیوه ی کار به این صورت است که یک سری درخواست DNS ارسال کنیم که هر بار یک مرتبه مقدار TTL در لایه ی IP ی آن افزایش می یابد. با توجه به هدف فعلی بهترین ابزار برای این کار scapy است. ابزاری که این امکان را فراهم می کند تا یک packet جدید بسازید و یا یک packet قبلی را با کمی تغییرات دوباره ارسال کنید.\nدر ادامه دو روش را بررسی می کنیم:\nساختن یک packet ساده کپی یک packet واقعی و تغییر جزئی آن. در واقع نباید بین این دو روش تفاوتی باشد، اما شواهد در بعضی شبکه ها، خلاف آن را ثابت می کند. همچنین در مطالب بعدی وجود cache برای درخواست های DNS نیز بررسی می شوند.\nطی بررسی این تحقیق، یک ابزار هم ساخته شده به اسم TraceVis که علاوه بر امکان انجام هر دو روش گفته شده به صورت راحت تر، یک گراف هم از کل مسیر می سازد. به همراه چند قابلیت دیگر.\nاما برگردیم به اصل مطلب و بررسی جزئیات.\nساختن یک packet ساده ی DNS over UDP : # ما میتوانیم این یک فایل با پسوند .py بسازیم و این کد را در آن قرار دهیم و یا درون برنامه ی Scapy این کد را اجرا کنیم.\n1 2 3 4 5 6 7 8 9 10 #!/usr/bin/env python3 from scapy.all import * for myttl in range(30): dns_request = IP(dst=\u0026#34;8.8.8.8\u0026#34;, id=RandShort(), ttl=myttl)/UDP(dport=53)/DNS(rd=1, id=RandShort(), qd=DNSQR(qname=\u0026#34;www.google.com\u0026#34;)) print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;request:\u0026#34; + \u0026#34; ip.dst: \u0026#34; + dns_request[IP].dst + \u0026#34; ip.ttl: \u0026#34; + str(myttl)) req_answer = sr1(dns_request, verbose=0, timeout=3) if req_answer is not None: print(\u0026#34; \u0026lt;\u0026lt;\u0026lt; answer:\u0026#34; + \u0026#34; ip.src: \u0026#34; + req_answer[IP].src + \u0026#34; ip.ttl: \u0026#34; + str(req_answer[IP].ttl)) print(\u0026#34; \u0026#34; + req_answer.summary()) print(\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026#34;) (اگر در خود scapy از این کد استفاده می کنید، این خط را وارد نکنید.)\n(اگر در خود scapy از این کد استفاده می کنید، این خط را نیز وارد نکنید.)\nبازه ی مقدار TTL را مشخص می کردیم. از 0 تا 30.\nیک packet ساده ی DNS over UDP ساختیم (بدون لایه ی Ether) . همچنین برای جلوگیری از ignore شدن packet، از ID های random استفاده کردیم.\nدر جواب دریافتی، مقدار IP ی مقصد و همچنین TTL ای که تنظیم کردیم را چاپ می کنیم.\npacket ساخته شده را بدون نمایش log و حداکثر زمان انتظار سه ثانیه ارسال کردیم.\nبررسی می کنیم که جواب دریافتی پوچ نباشد.\nمقدار IP ی مبدا ای که در حال جواب دادن به ما هست را به همراه TTL ای که در زمان دریافت packet مشاهده کردیم را چاپ می کنیم.\nیک خلاصه از جواب دریافتی هر چه که هست (DNS یا ICMP) را چاپ می کنیم.\nفقط خطی جدا کننده را چاپ می کنیم.\nاز سرور مورد تست (AS48147-امین داده) تا Hop یازدهم، به جای DNS جواب از نوع ICMP دریافت کردیم که به معنای این است که TTL صفر شده است و آن hop نیز مقصد مورد نظر ما نیست. بعد از آن، تمام جواب هایی که دریافت کردیم مقدار 56 در TTL داشتند و همراه با پاسخ DNS.\n\u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 0 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 1 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.8.3 ip.ttl: 255 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 2 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.6.2 ip.ttl: 254 IP / ICMP 172.22.6.2 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 3 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.9.2 ip.ttl: 62 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 4 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.5.49 ip.ttl: 252 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 5 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.4.83 ip.ttl: 251 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 6 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 85.185.45.133 ip.ttl: 250 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 7 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.4.206 ip.ttl: 251 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 8 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 213.202.4.172 ip.ttl: 249 IP / ICMP 213.202.4.172 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 9 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 213.202.5.239 ip.ttl: 238 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 10 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 216.239.48.133 ip.ttl: 50 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 11 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 216.239.51.115 ip.ttl: 52 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 12 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 13 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 14 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 15 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 16 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 17 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 18 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 19 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 20 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 21 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 22 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 23 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 24 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 25 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 26 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 27 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 28 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 29 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · همچنین به نظر می رسد که در این تست تا Hop سوم، که با آدرس 172.22 شروع می شود، همچنان در شبکه ی امین داده قرار دارد. بعد از آن تا Hop هفتم، در شبکه ی شرکت ارتباطات زیرساخت (AS12880). علاوه بر آن، مسیر برگشت در Hop های 7 و 8 یکسان است. که می تواند یا ناشی از تغییرات routing در شبکه باشد و یا نشان از جایی که firewall برای ایزوله کردن شبکه قرار دارد.\nدر ادامه، hob های 8 و 9 به در عمان‌تل (AS8529) قرار دارد. اما نکته ای وجود دارد و آن این است که در جواب ICMP درون این شبکه، بین hop های 8 و 9، حدود 11 واحد مقدار TTL تفاوت دارد. بدین صورت که اگر 255 را منهای 238 کنیم می شود 17. یعنی ما با 9 تا Hop به آن میرسیم اما پاسخ با 17 تا Hop به ما می رسد. این می تواند به این دلیل باشد که hop نهم، مسیر متفاوتی برای پاسخ دادن انتخاب می کند که با routing اصلی متفاوت است.\nدر ادامه Hop های 10 و 11 در در زیرساخت گوگل قرار دارند. اما هنوز درخواست ما به مقصد نرسیده است. اگر 64 را منهای 50 کنیم، می شود 14. یعنی ما با 10 تا Hop به زیرساخت گوگل می رسیم و 14 واحد مسیر برگشت پیام ICMP است.\nدر انتها بعد از hop دوازدهم و دریافت جواب از مقصد مورد نظر، TTL های دریافتی همیشه 56 هستند. که یعنی جواب، 8 تا Hop مسیر را طی می کند تا به ما برسد! (این را نیز در مطالب بعدی بیشتر بررسی خواهیم کرد.)\nما آدرس درخواستی را از www.google.com به www.twitter.com تغییر می دهیم تا ببینیم در کجای مسیر، DNS Hijacking انجام می شود:\nبعد از Hop چهارم به بعد، یعنی در شبکه ی شرکت ارتباطات زیرساخت، از ارسال Packet ها DNS ما که حاوی آدرس Twitter است جلوگیری می شود. لاگ کامل:\n\u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 0 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 1 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.8.3 ip.ttl: 255 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.twitter.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 2 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.6.2 ip.ttl: 254 IP / ICMP 172.22.6.2 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 3 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.9.2 ip.ttl: 62 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.twitter.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 4 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.5.49 ip.ttl: 252 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.twitter.com.\u0026#39;\u0026#34; / Padding · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 5 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 6 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 7 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 8 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 9 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 10 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 11 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 12 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 13 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 14 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 15 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 16 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 17 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 18 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 19 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 20 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 21 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 22 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 23 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 24 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 25 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 26 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 27 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 28 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 29 · · · − − − · · · · · · − − − · · · · · · − − − · · · (شبکه های مختلف، رفتار متفاوتی دارند و ممکن است این درخواست در شبکه ی شما بدون مشکل عبور کند.)\nاما سوالی به وجود می آید که آیا این یک سانسور عادی است و یا یک لیست سفید از Packet های DNS است؟ برای تست آن باید یک packet واقعی را کپی و دوباره ارسال کنیم.\nکپی یک packet واقعی ی DNS over UDP و تغییر جزئی آن: # یکی از قابلیت های مهم در برنامه ی Scapy امکان کپی کردن یک packet واقعی به صورت Hex و تغییر و ارسال مجدد آن است.\nراه های مختلفی برای دریافت Hex یک Packet دارد که در در بخش «آنالیز packet ها» بیشتر توضیح داده خواهد شد.\nدر اینجا برای سادگی کار، از tcpdump استفاده کردیم.\nابتدا این دستور را اجرا می کنیم:\n$ sudo tcpdump -s 0 -x \u0026#39;port 53\u0026#39; به معنای اینکه مقدار hex از لایه ی IP به بعد و فقط ترافیک پورت 53.\nبعد در یک پنجره ی دیگر، دستور مورد نظرمان را اجرا می کنیم:\n$ dig www.google.com @8.8.8.8 به صورتی که در تصویر مشخص شده بخشی از Packet مورد نظرمان که به صورت Hex است را کپی می کنیم:\nبرنامه ی scapy را اجرا می کنیم:\nابتدا دستور زیر را وارد می کنیم و enter می زنیم:\n\u0026gt;\u0026gt;\u0026gt; mypacket = IP(import_hexcap()) بعد محتوای کپی شده را paste می کنیم و enter میزنیم تا دوباره علامت \u0026lt;‌\u0026lt;‌\u0026lt; ظاهر شود:\nاگر نام متغیر ساخته شده را به تنهایی وارد کنید، جزئیات کامل این packet نمایش داده خواهد شد. اگر بجز لایه ی IP بقیه فقط Hex نمایش داده شد، کپی را به درستی انجام ندادید.\nبرای اینکه بتوانیم این packet را دوباره ارسال کنیم و انتظار جواب مثبت داشته باشیم، نیاز داریم که تغییراتی در آن انجام دهیم. کدی که در بالا استفاده کرده بودیم را کمی تغییر می دهیم و enter میزنیم تا دستور اجرا شود:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026gt;\u0026gt;\u0026gt; for myttl in range(30): mypacket[IP].ttl = myttl mypacket[IP].id = RandShort() mypacket[DNS].id = RandShort() mypacket[UDP].sport = RandShort() print(\u0026#34;\u0026gt;\u0026gt;\u0026gt;request:\u0026#34; + \u0026#34; ip.dst: \u0026#34; + mypacket[IP].dst + \u0026#34; ip.ttl: \u0026#34; + str(myttl)) del(mypacket[IP].chksum) del(mypacket[UDP].chksum) del(mypacket[IP].len) req_answer = sr1(mypacket, verbose=0, timeout=3) if req_answer is not None: print(\u0026#34; \u0026lt;\u0026lt;\u0026lt; answer:\u0026#34; + \u0026#34; ip.src: \u0026#34; + req_answer[IP].src + \u0026#34; ip.ttl: \u0026#34; + str(req_answer[IP].ttl)) print(\u0026#34; \u0026#34; + req_answer.summary()) print(\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026#34;) در این کد، TTL پیشفرض که 64 بود را به مقدار دلخواه خود تغییر دادیم. برای ID ی لایه ی IP ، برای ID ی DNS و برای پورت مبدا در UDP یک مقدار عددی random تعیین می کنیم. Checksum های مربوط به IP و UDP را حذف می کنیم تا هر بار دوباره توسط برنامه ی Scapy محاسبه و تعیین شود.\nتا Hop یازدهم تقریبا رفتار شبیه قبل است. (آدرس مورد آزمایش www.google.com است.)\nاما بعد از آن، ما رفتاری کاملا متفاوت می بینیم و هر بار با یک TTL متفاوت با فاصله ی 8 Hop تا 14 Hop. به معنای 6 واحد تفاوت در بین پاسخ ها.\nلاگ کامل:\n\u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 0 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 1 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.8.3 ip.ttl: 255 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 2 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.6.2 ip.ttl: 254 IP / ICMP 172.22.6.2 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 3 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.9.2 ip.ttl: 62 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 4 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.5.49 ip.ttl: 252 IP / ICMP 10.202.5.49 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 5 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.4.83 ip.ttl: 251 IP / ICMP 10.202.4.83 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 6 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 85.185.45.133 ip.ttl: 250 IP / ICMP 85.185.45.133 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 7 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.4.206 ip.ttl: 251 IP / ICMP 10.202.4.206 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 8 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 213.202.4.172 ip.ttl: 249 IP / ICMP 213.202.4.172 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 9 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 213.202.5.239 ip.ttl: 238 IP / ICMP 213.202.5.239 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 10 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 216.239.48.87 ip.ttl: 49 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.google.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 11 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 108.170.233.243 ip.ttl: 55 IP / ICMP 108.170.233.243 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 12 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 115 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 13 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 116 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 14 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 119 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 15 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 119 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 16 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 119 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 17 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 116 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 18 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 55 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 19 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 119 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 20 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 114 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 21 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 120 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 22 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 116 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 23 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 120 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 24 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 119 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 25 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 116 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 26 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 27 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 120 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 28 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 29 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 56 IP / UDP / DNS Ans \u0026#34;216.58.209.132\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · حالا همان مسیر قبلیِ کپی کردن Packet را در مورد آدرس www.twitter.com انجام می دهیم که در شیوه ی قبلی بعد از Hop چهارم وارد سیاهچاله می شد.\nدر این شرایط می بینیم که دوباره از Hop چهارم وارد سیاهچاله شده است اما از Hop نهم جوابی ارسال می شود که هم آدرس مربوط به صفحه ی سانسور جمهوری اسلامی برگردانده می شود و هم TTL آن بسیار پایین است. این مقدار TTL دریافتی با افزایش TTL ارسالی، افزایش می یابد. لاگ کامل:\n\u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 0 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 1 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.8.3 ip.ttl: 255 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.twitter.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 2 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.6.2 ip.ttl: 254 IP / ICMP 172.22.6.2 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 3 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 172.22.9.2 ip.ttl: 62 IP / ICMP / IPerror / UDPerror / DNS Qry \u0026#34;b\u0026#39;www.twitter.com.\u0026#39;\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 4 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 10.202.5.49 ip.ttl: 252 IP / ICMP 10.202.5.49 \u0026gt; 185.*.*.* time-exceeded ttl-zero-during-transit / IPerror / UDPerror / Raw · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 5 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 6 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 7 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 8 · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 9 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 1 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 10 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 2 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 11 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 3 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 12 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 4 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 13 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 5 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 14 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 6 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 15 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 7 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 16 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 8 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 17 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 9 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 18 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 10 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 19 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 11 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 20 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 12 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 21 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 13 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 22 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 14 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 23 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 15 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 24 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 16 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 25 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 17 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 26 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 18 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 27 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 19 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 28 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 20 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · \u0026gt;\u0026gt;\u0026gt;request: ip.dst: 8.8.8.8 ip.ttl: 29 \u0026lt;\u0026lt;\u0026lt; answer: ip.src: 8.8.8.8 ip.ttl: 21 IP / UDP / DNS Ans \u0026#34;10.10.34.35\u0026#34; · · · − − − · · · · · · − − − · · · · · · − − − · · · برای اطمینان از اینکه این رفتار چطور عمل می کند، که آیا افزایش نسبت به دفعات درخواست است و یا نسبت به TTL ارسالی، یک آزمایش بیشتر انجام می دهیم. برای این کار از همان کد قبلی استفاده می کنیم اما این بار range آن را از 30 تا 128 قرار می دهیم و مرتبه ی افزایش در هر بار را 3 قرار می دهیم.\nبا توجه به این آزمایش، به این نتیجه می رسیم که سیستم سانسور جمهوری اسلامی در صورت مواجهه با یک packet مرسوم DNS over UDP اگر آدرس درخواستی ممنوعه است، مقدار TTL دریافتی را در جواب DNS با محتوای آدرس صفحه ی سانسور قرار می دهد و آن را به سمت کاربر ارسال می کند.\nدلیل اینکه TTL ارسالی باید بیشتر از 8 باشد، این است که سیستم سانسور در این شبکه، در Hop پنجم قرار دارد. به این صورت که ما با TTL با مقدار 9 را ارسال می کنیم، سیستم سانسور TTL با مقدار 5 را دریافت می کند، آن را کپی کرده و در پاسخ به ما ارسال می کند و مقدار 1 به ما می رسد. و این بدین معنی است که سیستم سانسور در تست های ما از TTL با مقدار 4 در حال دریافت packet های ما است، اما فقط پاسخ آن است که به ما نمی رسد.\nاین یافته، وسعت بیشتری دارد که در مطالب بعدی به آن بیشتر خواهیم پرداخت.\nاستفاده از TraceVis # برای ساده سازی و درک بهتر این مسئله و وضعیت شبکه و سانسور، اقدام به ساخت ابزاری کردیم به اسم TraceVis که می توانید به راحتی تست های خود را انجام دهید.\nابتدا dependency ها را نصب کنید:\npython3 -m pip install -r requirements.txt و بعد تست را به این صورت اجرا کنید:\npython ./tracevis.py --dns و یا :\npython ./tracevis.py --dns -n \u0026#34;test-prefix\u0026#34; -i \u0026#34;1.0.0.1,8.8.4.4,9.9.9.9,5.200.200.200\u0026#34; به دلیل اینکه اولویت با دریافت جواب از Hop ها است و درستی نتیجه، ممکن است که این برنامه آهسته تر از توقع شما باشد.\nبعد از پایان یافتن تست که سه بار تکرار می شود، شما دو فایل دریافت خواهید کرد.\n********************************************************************** saving measurement data... saved: ./output/test-prefix-dns-tracevis-20211212-1551.json · · · - · - · · · - · - · · · - · - · · · - · - saving measurement graph... saved: ./output/test-prefix-dns-tracevis-20211212-1551.html · · · - · - · · · - · - · · · - · - · · · - · - یک فایل نتیجه ی آزمایش، از نوع json است که سازگار با ساختار RIPE Atlas است و یک فایل HTML که حاوی گراف.\nاین سازگاری به ما این امکان را می دهد تا علاوه بر داشتن یک ساختار استاندارد، به سادگی قابلیت ساخت گراف از طریق نتایج تست های traceroute در Probe های RIPE Atlas را نیز داشته باشیم.\nدر این گراف، به صورت پیشفرض رنگ های سرد برای آدرسی که فیلتر نیست در نظر گرفته شده و رنگ های گرم، برای آدرس فیلتر شده.\nدر تصویر زیر می بنید که هر دو مسیر به یک نقطه رسیدند و این به آن معنی است که جواب درخواست ها برای هر دو آدرس توسط یک دستگاه داده شده اند.\nاما این وضعیت برای تمام آدرس ها صدق نمی کند. و اگر مسیر packet از سیستم سانسور بگذرد، شما حالتی متفاوت خواهید دید.\nدر این تصویر درخواست به آدرس گوگل از شبکه ی داخلی خارج و به سرور مقصد رسید.\nاما در مورد آدرس توییتر، مسیر متفاوت است:\nوقتی در توضیحات علاوه بر اسم Middlebox، مقدار back-TTL عدد 6 قرار گرفت، یعنی Middlebox به اندازه ی 6 Hop فاصله دارد.\nیعنی در این موقعیت هایی که با پیکان مشخص شده:\nاین ابزار متن باز، قابلیت ها و امکانات بیشتری دارد. مانند امکان trace route با هر نوع packet از نوع TCP و UDP و ساخت گراف.\nمنتظر مشارکت شما در بهبود و توسعه ی این پروژه هستیم.\n"},{"id":4,"href":"/fa/docs/measure-internet-censorship/DNS/","title":"بررسی سانسور اینترنت در ارتباط DNS","section":"بررسی سانسور اینترنت: مقدمه","content":" بررسی سانسور اینترنت در ارتباط DNS # اولین قدم برای دسترسی به اینترنت DNS است. وقتی شما آدرس نام دامنه را وارد می کنید، این نام باید به IP تبدیل شود تا دستگاه شما بتواند با سرور آن ارتباط برقرار کند. این کار توسط DNS انجام می شود. یکی از بهترین ابزار ها برای بررسی سانسور در DNS نرم افزار dig است. که علاوه بر لینوکس و Mac OS، در ویندوز هم قابل استفاده است. (پکیج dnsutils و یا bind-utils در لینوکس)\nدر حال حاضر روش های مختلفی برای انجام تست DNS داریم. چند مورد پر استفاده و مهم از آنها عبارت اند از:\nDNS over UDP DNS over TCP DNS over HTTPS DNS over TLS DNS over UDP # DNS over UDP روش پیشفرض اکثر سیستم عامل ها است. این روش توسط شخص ناشناس قابل مشاهده و یا دستکاری است. اکثر سیستم های سانسور و بدافزار های شبکه، از این روش برای تغییر مسیر کاربران استفاده می کنند. در ایران معمولا جواب درخواست های DNS سایت های فیلتر شده به یکی از سه آدرس 10.10.34.34، 10.10.34.35، 10.10.34.36، تغییر می کنند.\nدر ارتباط IPv6 نیز، سانسور به صورت سیاهچاله عمل می کند و یا آدرس d0::11 را بر می گرداند.\nدرخواست DNS از طریق مقدار پیشفرض DNS تنظیم شده در سیستم عامل:\n$ dig twitter.com درخواست DNS با تنظیم دستی سرور DNS:\n$ dig twitter.com @8.8.8.8 نمایش این packet ها در نرم افزار wireshark:\nانجام این درخواست با ابزار پیشفرض سیستم عامل ویندوز:\n\u0026gt; nslookup twitter.com و تنظیم آدرس سرور DNS اختصاصی:\n\u0026gt;nslookup twitter.com 1.1.1.1 البته ممکن است همیشه چنین جوابی دریافت نکنید و درخواست های شما با جوابی همراه نباشند. در این شرایط درخواست ها وارد سیاه چاله می شوند.\n$ dig youtube.com در Wireshark هم می بینید که جوابی دریافت نشده:\nو همینطور در سیستم عامل و سرور DNS متفاوت:\n\u0026gt; nslookup youtube.com 1.1.1.1 نکته ی مهم این است که در ایران فرقی نمی کند که از چه سرویس ای درخواست می کنید. حتی فرقی نمی کند که آیا IP ای که درخواست می شود، واقعا سرویس DNS است یا خیر. و یا حتی فعال است یا خیر. به عنوان مثال، اگر از 1.1.1.1 استفاده می کنید و درخواستی دارید که فیلتر شده باشد، درخواست شما توسط سیستم سانسور ضبط می شود و به 1.1.1.1 نمی رسد و جوابی مثل 10.10.34.34 برای شما ارسال می کند.\nبرای امتحان، می توانید در سرور شخصی خود این دستور را اجرا کنید تا packet های ورودی مرتبط، به شما نشان داده شوند:\nمقدار آخر برابر با IP ی دستگاه ایران شما است و eth0 نام interface اصلی شما که می توانید با اجرای دستور زیر آن را به دست بیاورید:\n$ ip link show\nدر ادامه ی بحث اصلی، اگر درخواست را به صورت زیر وارد کنید:\nکه مقدار آخر برابر با IP ی سرور خارج شما است. چنین packet هایی در سرور دریافت می کنید:\nاما اگر یک سایتی که فیلتر شده را به جای آدرس google.com وارد کنید، packet ای در سمت سرور دریافت نمی شود و سیستم سانسور از سمت سرور ای که هیچ سرویس DNS در آن فعال نیست. IP ای از 10.10.34.3x را بر می گرداند:\nسیستم سانسور چین، معمولا یک IP ی random در جواب DNS سایت های سانسور شده برای کاربر ارسال می کند. از آنجایی که IP با آدرس درخواستی برابر نخواهد بود، نتیجتا باعث خطا می شود. یا سیستم سانسور بعضی از کشور ها 127.0.0.1 و یا 192.168.0.1 را در جواب سایت های سانسور شده ارسال می کنند. همچنین ممکن است بعضی از کشور ها از یک IP در دسترس اینترنت (IP public) برای سانسور استفاده کنند. مانند IP ای که ایران استفاده می کرده تا افرادی که سهوا و یا عمدا به سرویس های ممنوعه، همانند سایت قمار و شرطبندی، تلگرام، سرویس کوتاه کننده ی لینک و غیره رجوع می کردند، تحت پیگرد قانونی قرار دهد.\nIPv6 # برای دریافت IPv6 یک سایت، به صورت زیر عمل می کنیم:\n$ dig AAAA facebook.com @1.1.1.1 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.3-1ubuntu1.13-Ubuntu \u0026lt;\u0026lt;\u0026gt;\u0026gt; AAAA facebook.com ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 1468 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;facebook.com. IN AAAA ;; ANSWER SECTION: facebook.com. 1 IN A 10.10.34.35 ;; Query time: 35 msec ;; SERVER: 1.1.1.1#53(1.1.1.1) ;; WHEN: Tue Dec 29 22:52:29 +0330 2020 ;; MSG SIZE rcvd: 46 درخواست از نوع AAAA بوده اما جواب از نوع A و سانسور شده.\nو یا در ویندوز به صورت زیر عمل می کنیم :\n\u0026gt; nslookup -type=AAAA facebook.com 217.219.103.5 Server: UnKnown Address: 217.219.103.5 DNS request timed out. timeout was 2 seconds. Non-authoritative answer: Name: facebook.com Address: 10.10.34.35 البته این رفتار در هر شبکه و نسبت به هر resolver متفاوت است:\n\u0026gt; nslookup -type=AAAA facebook.com 5.200.200.200 DNS request timed out. timeout was 2 seconds. Server: UnKnown Address: 5.200.200.200 Non-authoritative answer: Name: facebook.com Address: 2a03:2880:f11c:8183:face:b00c:0:25de در اینجا جواب صحیح برگردانده شده است. اما اگر در شبکه ای که دارای IPv6 است و به سمت یک resolver با IPv6 تست کنیم نتیجه متفاوت خواهد بود:\n$ dig AAAA facebook.com @2001:4860:4860::8888 ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.3-1ubuntu1.13-Ubuntu \u0026lt;\u0026lt;\u0026gt;\u0026gt; AAAA facebook.com @2001:4860:4860::8888 ;; global options: +cmd ;; Got answer: ;; -\u0026gt;\u0026gt;HEADER\u0026lt;\u0026lt;- opcode: QUERY, status: NOERROR, id: 56730 ;; flags: qr rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0 ;; QUESTION SECTION: ;facebook.com. IN AAAA ;; ANSWER SECTION: facebook.com. 1 IN AAAA d0::11 ;; Query time: 28 msec ;; SERVER: 2001:4860:4860::8888#53(2001:4860:4860::8888) ;; WHEN: Tue Dec 29 22:56:41 +0330 2020 ;; MSG SIZE rcvd: 58 در اینجا جواب نیز از نوع AAAA است اما آدرس d0::11 که در پاسخ آمده، یک آدرس معتبر در IPv6 نیست. در نتیجه، همچون آدرس های 10.10.34.3x دارای صفحه ی «پیوند ها» نیست.\nلیست آدرس های مربوط به سیستم سانسور جمهوری اسلامی # برای پیگیری راحت تر موارد سانسور، آدرس هایی که توسط سیستم سانسور جمهوری اسلامی استفاده می شوند در ادامه همراه با لینک به یک نتیجه ی تست OONI که حاوی آن آدرس است، لیست می شوند:\n10.10.34.34 10.10.34.35 10.10.34.36 d0:0:0:0:0:0:0:11 d0::11 DNS over TCP # DNS over TCP هم از پورت مشابه DNS over UDP استفاده می کند و مشترکا Do53 معرفی می شوند. هر دوی اینها توسط شخص ناشناس قابل مشاهده است اما در ایران DNS over TCP به سمت سرور های خارجی دستکاری نمی شود. توجه داشته باشید که اگر از یک DNS داخلی استفاده کنید، در اکثر آنها فرقی نمی کند که شما از چه پروتکل ای استفاده می کنید و جواب IP ی صفحه ی سانسور برای شما برگردانده می شود.\n$ dig youtube.com +tcp استفاده از سرور خارجی:\n$ dig youtube.com +tcp @8.8.8.8 در ویندوز nslookup قابلیت DNS over TCP ندارد. خاطر همین ما از dig استفاده می کنیم:\n\u0026gt; .\\dig youtube.com +tcp \u0026quot;@8.8.8.8\u0026quot; گاهی مشاهده شده که بعضی درخواست هاتوسط سیستم سانسور وارد سیاهچاله می شوند.\n$ dig +tcp youtube.com @1.1.1.1 ;; Connection to 1.1.1.1#53(1.1.1.1) for youtube.com failed: timed out. ;; Connection to 1.1.1.1#53(1.1.1.1) for youtube.com failed: timed out. ; \u0026lt;\u0026lt;\u0026gt;\u0026gt; DiG 9.11.5-P4-5.1-Debian \u0026lt;\u0026lt;\u0026gt;\u0026gt; +tcp youtube.com @1.1.1.1 ;; global options: +cmd ;; connection timed out; no servers could be reached ;; Connection to 1.1.1.1#53(1.1.1.1) for youtube.com failed: timed out. DNS over HTTPS # DNS over HTTPS یا به اختصار DoH، معروف ترین نوع DNS رمزنگاری شده است که اکنون استفاده می شود. پورت پیشفرض اش معمولا 443 است و در هر نرم افزاری که می تواند درخواست HTTPS انجام دهد قابل پیاده سازی است.\nدر شرایط عادی شخص ناشناس فقط می تواند IP و یا نام دامنه (در صورت وجود) همین سرویس را مشاهده کند. اینکه درخواست و یا جواب چیست از دید شخص ناشناس پوشیده است. توضیح اینکه در شرایط عادی، برای آدرس سرور DoH، از نام دامنه استفاده می شود. به عنوان مثال https://dns.google/dns-query . قبل از اینکه درخواست DNS اصلی شما از سرور درخواست شود، باید آدرس dns.google به IP تبدیل شود. برای این کار از DNS پیشفرض سیستم عامل استفاده می شود که معمولا DNS over UDP است. بعد از انجام TCP handshake و بعد TLS handshake، درخواست کاربر که به صورت HTTP است رمزنگاری و ارسال و جواب دریافت می شود.\nدر حال حاضر سیستم عامل های Windows، MacOS، iOS و همچنین مرورگر های بر پایه ی Chromium مانند Chrome، Edge، Opera، Brave و غیره و مرورگر Mozilla FireFox از DoH پشتیبانی می کنند. در کروم، روش پیشفرض به این صورت است که اگر DNS ای که کاربر تنظیم کرده است، قابل ارتقا به DoH را نیز داشته باشد، از آن استفاده می کند، مگر اینکه کاربر روش دیگری را انتخاب کرده باشد. در فایرفاکس در صورت فعال کردن DoH، روش پیشفرض به این صورت است که اگر درخواست DoH با شکست مواجه شد، از DNS پیشفرض سیستم استفاده کند. که یعنی اگر DNS پیشفرض سیستم عامل کاربر از نوع DNS over UDP باشد، در این شرایط شخص ناشناس می تواند درخواست و جواب را مشاهده و یا دستکاری کند. امنیت ارتباط در این روش به اعتبار root CA سیستم عامل و یا برنامه ی مورد استفاده ی شما بستگی دارد.\nبرای انجام تست، می توانید از curl برای DoH استفاده کنید و جواب json دریافت کنید.\nدرخواست ساده از گوگل:\n$ curl -s \u0026#34;https://dns.google.com/resolve?name=www.who.int\u0026amp;type=A\u0026#34; {\u0026#34;Status\u0026#34;: 0,\u0026#34;TC\u0026#34;: false,\u0026#34;RD\u0026#34;: true,\u0026#34;RA\u0026#34;: true,\u0026#34;AD\u0026#34;: false,\u0026#34;CD\u0026#34;: false,\u0026#34;Question\u0026#34;:[ {\u0026#34;name\u0026#34;: \u0026#34;www.who.int.\u0026#34;,\u0026#34;type\u0026#34;: 1}],\u0026#34;Answer\u0026#34;:[ {\u0026#34;name\u0026#34;: \u0026#34;www.who.int.\u0026#34;,\u0026#34;type\u0026#34;: 5,\u0026#34;TTL\u0026#34;: 366,\u0026#34;data\u0026#34;: \u0026#34;www.who.int.cdn.cloudflare.net.\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;www.who.int.cdn.cloudflare.net.\u0026#34;,\u0026#34;type\u0026#34;: 1,\u0026#34;TTL\u0026#34;: 216,\u0026#34;data\u0026#34;: \u0026#34;104.17.113.188\u0026#34;},{\u0026#34;name\u0026#34;: \u0026#34;www.w ho.int.cdn.cloudflare.net.\u0026#34;,\u0026#34;type\u0026#34;: 1,\u0026#34;TTL\u0026#34;: 216,\u0026#34;data\u0026#34;: \u0026#34;104.17.112.188\u0026#34;}]} از Cloudflare :\n$ curl -H \u0026#39;accept: application/dns-json\u0026#39; \u0026#39;https://1.1.1.1/dns-query?name=www.who.int\u0026amp;type=A\u0026#39; {\u0026#34;Status\u0026#34;:0,\u0026#34;TC\u0026#34;:false,\u0026#34;RD\u0026#34;:true,\u0026#34;RA\u0026#34;:true,\u0026#34;AD\u0026#34;:false,\u0026#34;CD\u0026#34;:false,\u0026#34;Question\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;www.who.int\u0026#34;,\u0026#34;type\u0026#34;:1}],\u0026#34;Answer\u0026#34;:[{\u0026#34;name\u0026#34;:\u0026#34;www.who.int\u0026#34;,\u0026#34;type\u0026#34;:5,\u0026#34;TTL\u0026#34;:839,\u0026#34; data\u0026#34;:\u0026#34;www.who.int.cdn.cloudflare.net.\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;www.who.int.cdn.cloudflare.net\u0026#34;,\u0026#34;type\u0026#34;:1,\u0026#34;TTL\u0026#34;:239,\u0026#34;data\u0026#34;:\u0026#34;104.17.112.188\u0026#34;},{\u0026#34;name\u0026#34;:\u0026#34;www.who.int.cdn.cloudflare. net\u0026#34;,\u0026#34;type\u0026#34;:1,\u0026#34;TTL\u0026#34;:239,\u0026#34;data\u0026#34;:\u0026#34;104.17.113.188\u0026#34;}]} ( -H یک header به درخواست HTTP اضافه می کند.)\nدر بعضی نسخه های لینوکس می توان از دستور doh استفاده کرد:\n$ doh twitter.com و یا اگر می خواهید در درخواست curl از DoH استفاده کنید:\n$ curl --doh-url https://doh.powerdns.org/ https://www.google.com/.well-known/security.txt Contact: https://g.co/vulnz Contact: mailto:security@google.com Encryption: https://services.google.com/corporate/publickey.txt Acknowledgements: https://bughunter.withgoogle.com/ Policy: https://g.co/vrp Hiring: https://g.co/SecurityPrivacyEngJobs # Flag: BountyCon{075e1e5eef2bc8d49bfe4a27cd17f0bf4b2b85cf} در بعضی ISP ها ممکن است با خطا مواجه شوید که به دلیل شیوه ای از سانسور اینترنت است که در بخش مربوط به بررسی سانسور در HTTPS توضیح داده شد.\nDNS over TLS # DNS over TLS یا به اختصار DoT، روشی رمزنگاری شده از DNS over TCP است. نوع ارتباط در ALPN از نوع dot است و طبق استاندارد، بر روی پورت 853 باید سرویس دهی شود. شناسایی و مسدود کردن این نوع توسط سیستم های سانسور بسیار راحت تر از DoH است. اما محتوای درخواست ها و جواب ها توسط شخص ناشناس قابل مشاهده نیست. این نوع نیز همانند DoH در صورت استفاده از نام دامنه، متکی به سرویس DNS over UDP پیشفرض است.\nدر حال حاضر سیستم عامل های Android، Linux، iOS و MacOS از این نوع DNS پشتیبانی می کنند.\nدر آخرین نسخه از dig (نسخه ی تست شده:‌ 9.17.11 ) این امکان فراهم شد تا بتوان درخواست DoT داشت. به صورت استفاده از +tls:\n\u0026gt; .\\dig telegram.org +tls \u0026quot;@dns9.quad9.net\u0026quot; البته این قابلیت در dig هنوز به صورت کامل استاندارد ها را رعایت نکرده و به صورت رسمی در لحظه ی نوشتن این مقاله، این قابلیت رونمایی نشده.\nتوجه داشته باشید که DNS نقش حیاتی در امنیت ارتباطات شما دارد. اگر از DNS نامعتبر استفاده کنید و یا اینکه شخص ناشناس بتواند محتوای ارسالی و یا دریافتی آن را دستکاری کند، امنیت شما به خطر می افتد. به این دلیل همیشه سعی کنید از DNS های معتبر و با قابلیت رمزنگاری محتوا استفاده کنید. در ارتباطات رمزنگاری شده، یا شما مشکلی نخواهید داشت، و یا ارتباط با آن سرور تماما مسدود می شود.\n"},{"id":5,"href":"/fa/docs/measure-internet-censorship/Network/","title":"بررسی سانسور در ارتباط با سرور در لایه‌ی شبکه و انتقال","section":"بررسی سانسور اینترنت: مقدمه","content":" بررسی سانسور در ارتباط با سرور در لایه‌ی شبکه و انتقال # برای بررسی دسترسی به سرور معمولا از دو دستور ping و یا traceroute استفاده می شود. باید توجه داشته باشید که وقتی به صورت عادی از این دو دستور استفاده می کنید، شما قصد بررسی دسترسی IP دارید و اگر از آدرس دامنه برای آزمایش استفاده کنید، قبل از شروع درخواست، به صورت خودکار، یک بار از طریق DNS تنظیم شده در سیستم عامل شما، آدرس دامنه را به آدرس IP تبدیل می کند. در نتیجه اگر سانسور از طریق دستکاری DNS انجام شده باشد شما از طریق آدرس دامنه نمی توانید در دسترس بودن سرور از طریق IP را مورد بررسی قرار دهید.\nدستور ping # برای اجرای دستور ping در لینوکس می توانیم به صورت زیر عمل کنیم:\n$ ping -c9 google.com دستور ping در همه ی سیستم عامل ها از پروتکل ICMP استفاده می کند.\nTTL به معنای Time to live است و مقدار آن نمایانگر حداکثر دفعاتی است که یک packet می تواند در شبکه پرش کند. به طور معمول، TTL ها با مقدار 64 در لینوکس و Mac OS، مقدار 128 در ویندوز و مقدار 255 در روتر ها ارسال می شوند. در اینجا مقدار 111 می تواند به این معنا باشد که سرور با شما به اندازه ی 17 تا hop فاصله دارد. به این صورت که در صورت دستکاری نشدن packet در شبکه، احتمالا سرور با مقدار 128 آن را ارسال کرده و اگر 128 را منهای 111 کنیم، 17 باقی می ماند. (توضیحات بیشتری در این رابطه می تواند وجود داشته باشد که در آینده مطرح خواهد شد.)\ntime به معنای زمان سپری شده در ارسال و دریافت جواب به میلی ثانیه است.\nامکانات مفید برای این دستور:\n-v برای نمایش اطلاعات بیشتر -D برای نمایش زمان انجام آزمایش. -n برای resolve نکردن DNS در هر درخواست -c برای مشخص کردن حداکثر تعداد درخواست (نکته: بدون این موارد هم آزمایش به درستی انجام خواهد شد)\nاجرای دستور ping در ویندوز:\n\u0026gt; ping -n 9 google.com امکانات مفید برای این دستور در ویندوز:\n-t برای ping به صورت بی پایان -n برای مشخص کردن تعداد ping (پیشفرض 4 تا) همانطور که در ابتدا گفته شد، انجام دستور به شیوه ی زیر برای دامنه هایی که از طریق دستکاری DNS سانسور شده اند، درست نیست:\n$ ping -c9 twitter.com به این دلیل که با این کار در حال ping به IP ی صفحه ی پیوندها خواهیم بود، نه IP ی توییتر!\nبرای انجام درست این درخواست، ابتدا باید IP ی اصلی را به شیوه ای که درخواست DNS ما سانسور نمی شود دریافت می کنیم:\n$ dig twitter.com +short +tcp @8.8.8.8 104.244.42.1 104.244.42.129 بعد آن را به جای دامنه جایگذاری می کنیم: $ ping -c9 104.244.42.1 دستور ping با TCP # در مواردی ممکن است سرور و یا شبکه ای که سرور در آن قرار دارد تمام درخواست های ICMP را نادیده بگیرد و هیچ جوابی دریافت نکنید. برای اینکه درخواستی مشابه با ping داشته باشیم اما با پروتکل TCP، پروتکلی که برای ارتباط HTTP نسخه های قبل از 3 استفاده می شود، ابزارهایی وجود دارند مانند hping3 در لینوکس:\n$ sudo hping3 -S -p 443 -c 9 google.com به معنای\n-S انجام درخواست از نوع TCP با پرچم SYN\n-p تنظیم شماره ی Port\n-с تنظیم تعداد دفعات تست\nدر ویندوز نیز می توان از tcping استفاده کرد:\n\u0026gt; .\\tcping.exe -p 443 104.20.225.46 \u0026gt; .\\tcping.exe -p 443 104.20.225.45 دستور traceroute # دستور traceroute در لینوکس (پکیج traceroute، نه دیگری) استفاده می شود و در ویندوز از tracert. هر دوی اینها به شما این امکان را می دهند تا مسیر رفت (آپلود) تا سرور (نه مسیر بازگشت یا دانلود که احتمالا کمی متفاوت است) و hop های در میانه ی ارتباط را شناسایی کنید. و در صورت امکان، دلیل و یا مکان احتمالی اختلال و یا سانسور را متوجه شوید. اما دو تفاوت مهم بین این دو ابزار وجود دارد:\nدر traceroute به صورت پیشفرض از پروتکل UDP استفاده می شود اما در tracert فقط از پروتکل ICMP.\nدر traceroute امکان تغییر و سفارشی کردن پروتکل (ICMP, TCP و غیره) و پورت ها وجود دارد، اما در tracert نه.\nهمچنین نکات مهمی در این نوع بررسی وجود دارد که در انتها به آن پرداخت خواهد شد. اما چیزی که از قبل باید بدانید این است که زمان پاسخ، نمی تواند مطمئنا به معنای میزان تاخیر hop مورد نظر باشد. در اکثرمواقع routing ها به صورت سخت افزاری انجام می شوند و پردازش زیادی بر packet ها انجام نمی شود اما برای جواب دهی ممکن است میزان جواب های در صف و یا قدرت پردازش و همچنین اندازه ی جواب (شامل بودن و یا شامل نبودن تمام packet ارسالی) دخیل باشند.\nبرای اجرای دستور traceroute می توانیم به صورت زیر عمل کنیم:\n$ traceroute google.com در اینجا زمان پاسخ hop دوم حدود 30 میلی ثانیه است. و hop چهارم که در همان شبکه است با حدود 15 ثانیه تاخیر نسبت به پاسخ قبلی همراه بوده است. این می تواند ناشی از تاخیر در پاسخ دادن خود hop سوم باشد و یا مشکل در routing بین hop های دوم و سوم.\nتا اولین پاسخ hop هفتم روند تاخیر افزایشی بوده و بعد حدود 25 میلی ثانیه کاهش در تاخیر مشاهده شده. این مسئله می تواند ناشی از کاهش بار شبکه باشد و یا تغییر routing در مسیری که بار کمتری بر روی آن است. باید توجه داشت که با توجه به تغییر سریع و غیر قابل پیشبینی مسیر ها در این شبکه، نمی توان مطمئن بود که جواب اول و دوم در hop هفتم، دقیقا از مسیر هایی رفت و یا برگشت ای عبور کردند که ما در hop های قبل از آن مشاهده کردیم.\nدر hop های هشتم و نهم، یکسان هستند. معمولا این حالت و موارد بازگشتی دیگر نشان از شبکه ی wall-gardened دارد. یعنی این نقطه، دیوار بین شبکه ی درون و بیرون است. جایی که نظارت و کنترل بر ورود و خروج محتوا صورت می گیرد. با توجه به ساختار شبکه ی ایران، احتمالا این فقط یکی از این دیوار ها و یا firewall های درون شبکه است.\nدر ادامه ی hop دوازدهم، ارتباط بیش از حد طولانی شده است و تمام پاسخ ها و یا درخواست ها سانسور شدند. این کار ممکن است توسط خود hop دوازدهم انجام شود و یا توسط hop سیزدهم. این روش احتمالا برای از بین بردن شواهد و مخفی کردن ادامه ی مسیر است.\nهمینطور در انتها، در پاسخ سرور مورد بررسی ما، درخواست دوم با timeout مواجه شده است. (علامت ستاره * ) که ممکن است به دلیل سانسور موقتی و یا افزایش مسیر در آن لحظه باشد. به این صورت که همچنان با سی hop در آن لحظه packet ارسالی ما به سرور نرسیده و اما جواب ICMP همچون قبل از آن، در مسیر بازگشت سانسور شده است.\nدر ابتدا IP هایی که با 172 شروع می شوند، متعلق به شرکت شاتل هستند. بررسی با Looking glass مرکز فیزیک نظری :\nو در ادامه مواردی مانند hop دوازدهم که با 10 شروع می شوند متعلق است به شرکت ارتباطات زیرساخت:\nهمانطور که گفته شد اگر سرویسی از طریق DNS مسدود است و ما DNScrypt/DoT/DoH ای نداریم، باید از IP برای تست استفاده کنیم. به عنوان مثال برای تست یکی از IP های توییتر:\n$ traceroute 104.244.42.1 نکته ی جالب در این دو traceroute که در شبکه ی شاتل انجام شده است این است که مسیر مربوط به دامنه ی گوگل بیشتر از توییتر است. دلیل این مسئله به احتمال زیاد bandwidth-throttling است. تکنیکی برای کاهش سرعت یک سرویس. اما اثبات این تکنیک، راحت نیست. چرا که از طرفی می بینیم که پاسخ از سرور توییتر زمان بیشتری نسبت به پاسخ سرور گوگل صرف کرده است.\nالبته باید توجه داشته باشید که هر ISP نسبت به هر پروتکل ممکن است رفتار متفاوتی نشان دهد. و یا این رفتار فقط در بعضی زمان ها اتفاق بیفتد و یا نسبت به تمام IP های یک سرویس چنین رفتاری نشان ندهد. تست دوباره:\n$ traceroute google.com همانطور که در تصویر مشخص است، IP متفاوت، رفتار متفاوتی دارد. اما در انتها دو درخواست اولیه با timeout مواجه شدند که قبلا در مورد این مسئله توضیح داده شده است. (یا سانسور و یا تغییر route)\nپیش تر گفته شده که پروتکل پیشفرض traceroute در سیستم عامل های Unix-like مانند لینوکس، macOS و غیره، UDP است. اما این امکان وجود دارد که با افزایش دسترسی، از پروتکل های دیگر نیز برای این کار استفاده کنید.\nبه عنوان مثال پروتکل ICMP :\n$ sudo traceroute google.com --icmp و همانطور که گفته شد، در ویندوز با tracert فقط می توانید با پروتکل ICMP این کار را انجام دهید:\n\u0026gt; tracert google.com اما چیزی که بیش از هر چیز ممکن است نیازتان شود، پروتکل TCP است:\n$ sudo traceroute google.com --tcp در اینجا می بینیم که سومین hop به گوگل رسیدیم. یعنی مستقیم بعد از ISP ! آن هم در کمتر از 40 میلی ثانیه که با توجه به آزمایش قبلی (و بعدی) که حدود 150 میلی ثانیه بود و با اختلالات ساختاری و خلاقیت های شبکه ی داخلی ایران، این سرعت کاملا دور از واقعیت است. دلیل این اتفاق چیز دیگریست که در بخش بعدی مربوط به ارتباط HTTP توضیح داده خواهد شد.\nبه دلیل اینکه port پیشفرض برای TCP مقدار 80 است، در مورد بعدی، علاوه بر تغییر port به 443، برای ساده سازی نمایش، تعداد هر بار query در هر TTL را هم به 1 تغییر دادیم و همینطور در بخش option تنظیم کردیم که اطلاعات بیشتری از جواب های از نوع TCP برای برای ما نشان دهد:\n$ sudo traceroute google.com --tcp --queries=1 -O info --port=443 در اینجا می بینید که مسیر در پورت 443 متفاوت است و بعد از hop دوازدهم، تمام پاسخ های ICMP سانسور شدند. درخواست ارسالی TCP است و با TTL به مقدار 20 به سرور رسیده و جواب SYN,ACK دریافت شده. اما hop های میانه که با TTL صفر مواجه می شوند، جواب ICMP بر می گردانند. در نتیجه، در اینجا، این جواب های ICMP هستند که سانسور می شوند.\nتا سال گذشته در بیشتر مواقع در جواب درخواست به IP های مسدود شده، به جای پاسخ هایی با پرچم SYN,ACK، پاسخ با پرچم RST,ACK دریافت می شده است. این packet دریافتی، گاهی دستکاری جواب SYN,ACK سرور بود و گاهی مستقیما از سیستم سانسور ارسال می شد. که برای اطمینان در این موارد باید ترافیک کل stream آنالیز شود. اما RST همیشه به معنی سانسور نیست. گاهی سرور در اثر باز نداشتن آن port و یا تنظیم اشتباه، این پیام را بر می گرداند. به عنوان مثال از یک ISP ای دیگر در ایران به سمت سایت همراه اول traceroute انجام می دهیم:\n$ sudo traceroute --tcp --port=443 -O info -m 50 mci.ir در اینجا می بینیم که سایت همراه اول نسبت به درخواست ها از غیر از شبکه ی خودش حساس است و از آن امتناع می کند. همچنین دو درخواست اولیه همراه با SYN,ACK نبودند. این ممکن است که جواب دریافتی به جای TCP از نوع ICMP بوده باشد و این بدان معنی است که احتمالا رفتاری از firewall باشد.\nاین تست را چند بار تکرار می کنیم:\nدر تست دوباره، فقط یک بار در بار دوم SYN,ACK به درستی دریافت شد و دو مورد دیگر RST,ACK بودند.\nاما در سیستم سانسور، اخیرا برای اتلاف بیشتر وقت و عمر کاربران، از ارسال هر جوابی به کاربر اجتناب می شود. به عنوان مثال، IP ی مربوط به آدرس t.me را بررسی می کنیم:\n$ sudo traceroute 149.154.167.99 --tcp --port=443 -O info طبق trace های قبلی، تا hop هفتم همچنان در بستر ISP قرار داریم. این یعنی قبل از ورود به بستر شرکت ارتباطات زیرساخت، از ادامه ی ارتباط جلوگیری شده است و به عبارتی دیگر این مسدود سازی در سطح ISP انجام شده.\nسانسور مسیر ورودی # همانطور که در ابتدا گفته شد، مسیر رفت با مسیر بازگشت ممکن است متفاوت باشد و همیطور ممکن است سانسور فقط در یکی از این دو صورت بگیرد.\nدر مواردی مانند سانسور Clubhouse شاهد این بودیم که در بعضی شبکه ها، بعد از خروج از کشور دیگر جوابی دریافت نمی شود:\n$ sudo traceroute 104.20.225.46 --tcp --port=443 اما در همان IP range در hop دهم به جواب می رسیدیم:\n$ sudo traceroute 104.20.225.45 --tcp --port=443 و یا در شبکه ای دیگر:\n$ sudo traceroute 104.20.225.46 --tcp --port=443 این مسئله فقط می تواند به این دلیل باشد که تمام packet های ارسالی از سرور مورد تست ما مسدود می شوند. برعکس مثال های قبل که packet ارسالی از کلاینت مسدود می شدند.\nدر traceroute همچنین این امکان وجود دارد تا مسیر برگشتی محاسبه شود. به این صورت که TTL های ارسالی از hop ها به صورت سه مورد اصلی 255 (روتر)، 128 (ویندوز) و 64 (لینوکس/یونیکس) در نظر گرفته می شوند و TTL جواب، منهای یکی این سه که محتمل تر هستند می شود.\n$ sudo traceroute google.com --tcp --port=443 -O info --back به عنوان مثال، می بینیم که در hop هشتم مسیر برگشت یک واحد طولانی تر است و hop دهم نیز همانند hop هشتم است. (firewall یا سیستم سانسور ایران)\nسانسور پورت خاص # گاهی سانسور بر مبنای port است. طبق این توییت بعضی پورت ها یا پروتکل ها محدود شدند.\nقابل توجه :\n\u0026quot; #شاتل به صلاح دید خود، در راستای حفظ امنیت شبکه، می‌تواند بدون اطلاع رسانی دسترسیهای مشترک به پورت یا پروتکلها را محدود کند. در حال حاضر موارد محدود شده به شرح جدول زیر است. \u0026quot;\nوقتی میگیم تو این مملکت اینترنت نیست از همین جاها شروع میشه.#adsl pic.twitter.com/ddTY26326H\n\u0026mdash; Matin (@matinrco) March 18, 2020 برای آزمایش، ما پورت مربوط به SMB ویندوز که برابر با 445 است را در TCP بررسی می کنیم:\nsudo traceroute google.com --tcp --port=445 علامت !X در traceroute به معنی \u0026ldquo;communication administratively prohibited\u0026rdquo; است. یعنی این ارتباط، هرچه که هست، در hop چهارم ممنوع اعلام شده. (برخلاف !Z که فقط مقصد مورد توجه است) حالا ارتباط UDP در Port 445 که در تصویر نیست:\ntraceroute google.com --udp --port=445 که باز هم نشان از این دارد که ISP ارتباط UDP به این سرور را هم مسدود کرده است.\n(SMB آسیب پذیری های زیادی داشته. اما بستن هر چیز به جای آموزش درست، راه حل نیست، حذف کردن صورت مسئله است. اگر واقعا برای جلوگیری از حمله باشد، این کار تاثیر چندانی ندارد. این حمله بدون استفاده از ISP ی شاتل هم می تواند در شبکه ی داخلی سازمان و یا کاربر اتفاق بیفتد.)\nدر چه صورت traceroute می تواند سندی از کاهش سرعت باشد؟ # یک موضوع که ممکن است بتواند برای بررسی این مسئله مورد استفاده قرار بگیرد که کدام hop در حال ایجاد اختلال در ارتباط است، بررسی زمان پاسخ های آنها است. اما فقط به شرطی که hop های بعدی نیز حداقل به میزان hop قبلی تاخیر داشته باشند. این موضوع در مورد packet loss هم صدق می کند.\nبه این نتیجه از برنامه ی MTR دقت کنید:\n$ mtr instagram.com با توجه به مقدار packet loss، در hop دهم هیچ جوابی دریافت نشد. یعنی 100٪ packet loss، اما این به معنی مسئول بودن در کاهش سرعت نیست. چرا که در hop بعدی میزان کمتر است و به 22.2٪ و در hop بعد از آن به 0٪ رسیده است. همین مسئله در مورد hop های بعدی مثل hop سیزدهم صدق می کند.\nبا توجه به میزان تاخیر در پاسخ، بجز تاخیر تا ارتباط با ISP در hop دوم، تاخیر جدی اولیه با میزان تاخیر بیش از ده ثانیه، که در امتداد مسیر ادامه دارد، hop سوم است. همچنین دراین hop می بینیم که StDev یا انحراف معیار به مقدار 5 است. این به معنی نوسان زیاد در پاسخ این دستگاه است.\nبا توجه به زمان تاخیر، احتمالا تاخیر جدی دوم، hop دهم است. درhop یازدهم این تاخیر نمایان می شود که حدود 70 میلی ثانیه تاخیر وجود دارد. همچنین یک تاخیر قابل توجه سوم ای به میزان 100 میلی ثانیه هم وجود که در hop دوازدهم و یا در بین hop های یازدهم و دوازدهم اتفاق افتاده است.\nاز hop دوازدهم به بعد، میزان تاخیر بسیار کم است اما همچنان میزان انحراف معیار بالا است.\nدر انتها، در پاسخ سرور (27)، میزان loss و StDev نرمال است و مشکلی وجود ندارد. این بدانس معناست که در این ارتباط، بجز تاخیر، مشکل دیگری وجود ندارد.\nباید توجه داشت که وظیفه ی اصلی روترها انتقال packet ها است نه پاسخ به درخواست های مستقیم. درنتیجه حتی گاهی مسئولین شبکه یک rate limit برای ICMP در روتر در نظر میگیرند. که این مسئله می تواند منجر «توهم packet loss» شود. چون در واقع وظیفه ی اصلی روتر که انتقال packet ها هست، به درستی انجام می شود.\nاین نکته باید تاکید شود که این اندازه گیری ها باید چند بار تکرار شوند تا از پایداری این شیوه های اختلال اطمینان حاصل شود. به دلیل اینکه همانطور که پیش تر گفته شد، ممکن است مسیر ارتباط بارها تغییر کند و در آن لحظه ی مشاهده ی تاخیر، packet های ارسالی از مسیری عبور نکند که قبل از آن لیست شده اند. ( در مورد شرایط احتمالی در mtr بیشتر بخوانید. )\nدر ویندوز ابزاری مشابه با کمی تفاوت وجود دارد به اسم pingpath :\n\u0026gt; pathping 34.234.142.160 این ابزار این امکان را فراهم می کند که تفاوت بین عدم پاسخ hop و ایجاد اختلال در ارتباط مشخص شود. البته این مسئله باز هم ممکن است تحت تاثیر موارد دیگری قرار بگیرد و نمی تواند قطعیت داشته باشد. به عنوان مثال، این ابزار فقط تا hop ای اندازه گیری خواهد که با timeout برخورد نکند. همچنین تغییر routing سریعی که در برخی نقاط در شبکه اتفاق می افتد، سلامت داده ی این نوع اندازه گیری ها را زیر سوال می برد.\nبه عنوان مثال در این تصویر می بینید که در hop های چهارم تا هفتم در هر سه packet ای که ارسال می شود، یک روتر جدید به آن پاسخ می دهد. در نتیجه مشخص نیست که در hop های بعد از چهارم، packet ما از چه مسیری رفته و از چه مسیری بازگشته است!\nبه این صورت در نظر بگیرید که اگر در hop پنجم یک روتر مشکل ساز وجود داشته باشد که در سه بار تست پیشفرض در traceroute (در MTR و PathPing تنها یک بار) قابل مشاهده نباشد، نتیجه ی آن را ممکن است در hop های بعدی ببنید که در واقع ربطی به آنها ندارد.\n"},{"id":6,"href":"/fa/docs/measure-internet-censorship/Application/","title":"بررسی سانسور در ارتباط با سرور در لایه‌ی کاربرد","section":"بررسی سانسور اینترنت: مقدمه","content":" بررسی سانسور در ارتباط در لایه ی کاربرد # در ارتباط عادی، سومین مرحله از بازدید یک سایت و یا استفاده از سرویس، ارتباط با برنامه ی نصب شده در سرور است. به عنوان مثال Apache، IIS، و یا هر سرویس ساده ی دیگر.\nبهترین ابزار بررسی ارتباط با پروتکل های HTTP، HTTPS، MQTT و FTP و غیره، curl است که اکثر سیستم عامل ها را پشتیبانی می کند.\nبرای بررسی روش هایی که یک سایت در لایه ی بالاتر از IP مسدود شده، اولین قدم بررسی ارتباط HTTP است. اما توجه به این نکته مهم است که در این بررسی نیز باید از IP اصلی استفاده کنیم، نه چیزی که سیستم سانسور به ما می دهد.\nارتباط HTTP # در این سطح ما می خواهیم که DNS Hijacking در تست ما دخیل نباشد و در قدم اول فقط می خواهیم ببینیم که اگر از IP ی درست استفاده کنیم، باز هم ارتباط HTTP سانسور می شود؟ :\n\u0026gt; .\\curl -v --doh-url \u0026quot;https://mozilla.cloudflare-dns.com/dns-query\u0026quot; http://twitter.com/ (تصویر از انتهای لاگ \u0026ndash; تست شده در ویندوز)\nدر خط اول می بینید که درخواست DoH به درستی کامل شد. در نتیجه IP ی دریافت شده درست است.\nدر ادامه، به سایت توییتر با آدرس دریافت شده، درخواست فرستاده شد و چون ارتباط HTTP است، یعنی رمزنگاری نیست و به راحتی توسط شخص ناشناس قابل دستکاری است، خطای 403 در Header و iframe ای که صفحه ی سانسور جمهوری اسلامی را نمایش خواهد داد، دریافت شد.\nبرای آزمایش مشابه، اگر قصد وصل شدن به یک IP ی خاص داریم، می توانیم به این صورت از curl استفاده کنیم:\n\u0026gt; .\\curl -v --resolve twitter.com:80:104.244.42.193 http://twitter.com/ مقدار 80 به معنای Port ای است که قصد وصل شدن به آن را داریم.\n--resolve برای قرار دادن یک IP در DNS cache موقت curl است.\nحال سوالی که پیش می آید این است که آیا این سانسور، بر مبنای مقدار Host در header است و یا بر مبنای محتوای درخواست، و یا هر دو؟\nبرای بررسی، می توانیم از آدرسی که می دانیم که سانسور نیست استفاده کنیم. مانند example.com :\n\u0026gt; .\\curl -v http://example.com در اینجا می بینیم که HTTP 200 OK دریافت شده و مقدار title برابر با مقداری است که با اینترنت بدون سانسور به دست می آوریم. این بدان معناست که در این شبکه ارتباط با این دامنه و IP سانسور نمی شود.\nحال که از مسدود نبودن آن مطمئن هستیم، می توانیم از این IP برای آزمایش استفاده کنیم. در curl، علاوه بر --connect-to و --resolve می توانیم از -H یا --header نیز استفاده کنیم. به این معنا که ما قصد اضافه کردن و یا باز نویسی یک header در HTTP داریم. به این صورت:\n\u0026gt; .\\curl -v -H 'Host: twitter.com' http://93.184.216.34 در اینجا آدرس توییتر در header به عنوان Host انتخاب شد اما خطای 503 دریافت کردیم.\nدرخواست مشابه را از طریق سرور خارجی انجام می دهیم تا واکنش سرور را نسبت به این درخواست ببینیم و مطمئن شویم که این خطا، خطایی مربوط به سرور نیست:\nهمانطور که انتظار می رفت، این خطا خارج از سیستم سانسور جمهوری اسلامی مشاهده نشده است.\nاین خطایی است که از سمت سیستم سانسور جمهوری اسلامی، به دلیل ناتوانی در تحلیل به موقع درخواست باز می گرداند. در اینجا می توانید ببینید که در یک تست کامل توسط OONI-probe تعداد 329 آدرس این خطا را دریافت کردند. حدود 15٪ از کل لیست (شامل اکثریت پروتکل HTTPS).\nحال برای بررسی دقیق زمان واکنش --trace-time را اضافه می کنیم:\n\u0026gt; .\\curl -v --trace-time -H 'Host: twitter.com' http://93.184.216.34 زمان پاسخگویی با خطای 503، دقیقا 30 ثانیه تنظیم شده است. چند بار این تست را تکرار می کنیم و بعد از گذشت چند دقیقه از درخواست اولیه، سیستم سانسور جواب معمول خود را برای سانسور، ارسال می کند:\nحال آزمایش می کنیم که سیستم سانسور جمهوری اسلامی نسبت به ارتباط با IP ی توییتر، اما دامنه ی example.com در header چه واکنشی نشان می دهد:\n\u0026gt; .\\curl -v -H 'Host: example.com' http://104.244.42.193/ جواب تعجب برانگیزی دریافت شده است. در حالت عادی شما نمی توانید از IP یک سایت دیگر استفاده کنید و جواب یکسان بگیرید. مگر اینکه هر دو بر روی یک هاست اشتراکی باشند و یا هر دو از CDN خاصی استفاده کنند که از domain-fronting پشتیبانی می کند.\nبرای اطمینان دوباره از سرور خارجی همین درخواست را تکرار می کنیم:\nجواب متفاوت است. در نتیجه، پاسخ قبلی احتمالا به دلیل وجود سیستم Cache در اینترنت آن شبکه است. در بخش «لایه ی شبکه و انتقال»، نشان داده شد که در دستور traceroute با Port 80 و به صورت TCP، بعد از فقط ۳ Hop، با تاخیر بسیار پایین، از سرور مقصد جواب دریافت می کردیم. این سیستم احتمالا فقط بر مبنای مقدار Host کار می کند و IP را برای درخواست نهایی مد نظر قرار نمی دهد.\nیک تست دیگر انجام می دهیم. با IP ی تلگرام و دامنه ی iran.ir :\n\u0026gt; .\\curl -v -H 'Host: iran.ir' http://149.154.167.99/ در نتیجه، IP اگر مسدود باشد، از آن جلوگیری می شود، تفاوتی وجود ندارد. به جای تلگرام از IP ی Wikipedia استفاده می کنیم:\n\u0026gt; .\\curl -v -H 'Host: iran.ir' http://91.198.174.192/ دوباره خطای 503 دریافت کردیم که به نظر سیستم Cache جمهوری اسلامی برای آدرس iran.ir آماده نبود.\nاین بار به جای آدرس iran.ir از google.com استفاده می کنیم که می دانیم که به تازگی حداقل یک بار توسط مردم درخواست داده شده است:\n\u0026gt; .\\curl -v -H 'Host: google.com' http://91.198.174.192/ همانطور که انتظار می رفت، جواب داده شد. همین درخواست را دوباره از سرور خارج انجام می دهیم:\nمی بینیم که جواب متفاوت است. دوباره همین درخواست را از ایران انجام می دهیم و www. را اضافه می کنیم:\n\u0026gt; .\\curl -v -H 'Host: www.google.com' http://91.198.174.192/ محتوای صفحه ی گوگل از طریق IP ی ویکی‌پدیا به صورت کامل دریافت شده است. با توجه به ساعت درخواست، به نظر درخواست در همان لحظه انجام شده و در نتیجه این یک middle box در سیستم سانسور جمهوری اسلامی است.\nدر این رابطه، در گذشته گزارشی توسط Citizenlab منتشر شده که رویکرد سیستم سانسور ای که توسط شرکت کانادایی Netsweeper ساخته شده را به صورت زیر به تصویر کشیده است:\nارتباط HTTPS # همانند HTTP ما نباید سانسور از طریق DNS hijacking را در این سطح از آزمایش ها دخیل کنیم. برای این کار، از همان روش های توضیح داده شده در ارتباط HTTP میتوانیم استفاده کنیم. بجز اینکه تمام header ها و آدرس ها رمزنگاری می شوند و در نتیجه توسط سیستم سانسور قابل مشاهده نیستند تا نسبت به آنها سانسور شدن یا نشدن تصمیم گیری شود. اما موارد جدیدی وجود دارند که سیستم سانسور نسبت به آنها تصمیم گیری کند و در صورت تمایل، از ادامه ی ارتباط جلوگیری کند.\nاولین مورد می تواند SNI باشد. بخشی در ارتباط TLS که به سرور این اطلاع را می دهد که کاربر قصد وصل شدن به چه host ای دارد.\nSNI در Client Hello قرار دارد. اما بعد از این packet، سرور Server Hello را ارسال می کند که اگر زیر نسخه ی TLSv1.3 باشد، محتوای сerfiticate به صورت plain text ارسال می شود. در گذشته از این طریق شناسایی محتوای رمزنگاری نشده در این packet، ارتباط سرورهای اینستاگرام در ایران مسدود شده بود. (تنها کشوری که تاکنون مشاهده شده که چنین کاری انجام داده است)\nاما با پیشرفت تکنولوژی این ضعف دیگر در نسخه های جدید وجود ندارد. البته برای حل مشکل SNI نیز استانداردی در حال نوشته شدن است که extension های با اطلاعات حساس در Client Hello به صورت رمزنگاری شده در extension جدیدی به نام ECH قرار بگیرند.\nدر حال حاضر ارتباط HTTPS به چند صورت مسدود می شوند:\nاز طریق SNI از طریق fingerprint در TLS مسدود سازی TLS به صورت کلی مسدود سازی ارتباط به صورت random در مورد مسدود سازی ها از طریق fingerprint و مسدود کردن های random، در بخش هایی مجزا توضیح داده خواهد شد. در ادامه به دو مورد ساده تر می پردازیم.\nبررسی ساده ی SNI و TLS # دسترسی به توییتر را با تنظیم دستی timeout به مدت 30 ثانیه مورد آزمایش قرار می دهیم:\n$ curl -v -m 30 --doh-url https://mozilla.cloudflare-dns.com/dns-query https://twitter.com/ در اینجا می بینیم که بعد از Client hello و بعد از گذشت 30 ثانیه، با پیام timeout ارتباط بسته شده است. این به این دلیل است که در این اتفاق احتمالا به دلیل SNI است اما برای اطمینان باید بررسی بیشتر انجام دهیم.\nبرای اینکه ببینیم که آیا سیستم سانسور به نام توییتر در SNI حساس است یا مسئله ی دیگر، باید از IP سایتی که می دانیم فیلتر نیست استفاده کنیم و اما از آدرس توییتر در SNI استفاده کنیم. مانند دستور زیر که از IP ی سایت example.org استفاده کردیم:\n$ curl -v -m30 --resolve 'twitter.com:443:93.184.216.34' https://twitter.com/ به دلیل اینکه پیامدی مشابه داشته، به این نتیجه می رسیم که این مسدود سازی از طریق شناسایی آدرس twitter.com در بخش SNI در Client hello صورت گرفته است.\nاما سیستم سانسور جمهوری اسلامی گاهی رفتاری متفاوت نیز دارد.\nبرای نشان دادن نمونه های بیشتر، این بار آدرس dns.google را امتحان می کنیم:\n$ curl -v -m30 https://dns.google/ همانند قبل ارتباط بعد از Client hello وارد سیاه چاله شده است.\nدر ادامه تست مسدود بودن SNI را انجام می دهیم و از IP ی سایت example.org استفاده می کنیم:\n$ curl -v -m30 --resolve dns.google:443:93.184.216.34 https://dns.google/ در ایجا می بینیم که TLS handshake به صورت کامل انجام شده است. (خطا به خاطر همسان نبودن Certificate ارسالی از سرور و آدرس درخواستی است)\nبنابراین مسدود سازی نمی تواند صرفا به خاطر آدرس dns.google باشد. سوال این است: آیا از هر ارتباط TLS به سمت آدرس 8.8.4.4 جلوگیری می شود؟\nبرای پاسخ به این سوال، این بار از آدرس IP ی dns.google استفاده می کنیم اما از آدرس دامنه ی example.com برای SNI استفاده می کنیم:\n$ curl -v -m30 --resolve example.com:443:8.8.4.4 https://example.com/ در اینجا می بینیم که سیستم سانسور جمهوری اسلامی فقط نسبت به هر ارتباط TLS به این IP حساس است و آدرس دامنه را ملاک قرار نمی دهد.\nالبته این رفتار در همه ی شبکه ها و یا نسبت به همه ی آدرس ها یکسان نیست. به عنوان مثال، تست های بالا را که در مخابرات (AS58224) انجام شده بود را در همراه اول (AS197207) تکرار می کنیم:\n$ curl -v -m30 --resolve dns.google:443:8.8.4.4 https://dns.google/ می بینیم که بعد از به پایان رسیدن TLS Handshake ارتباط وارد سیاه چاله شده است؛ زمانی که ارتباط HTTP شروع می شود. این می تواند به دلیل تاخیر در واکنش سیستم سانسور باشد که اولین بار این رفتار در چین مشاهده شد.\nالبته در اینجا حساسیت فقط به آدرس dns.google نیست. به عنوان مثال در تست بعدی، همانند قبل پیش می رویم و از IP ی سایت example.com استفاده می کنیم. همچنین به دلیل اینکه مسدود شدن ارتباط بعد از TLS Handshake اتفاق افتاده بود، در تست بعدی از -k نیز استفاده می کنیم تا تفاوت certificate با آدرس درخواستی در SNI، باعث پایان یافتن ارتباط قبل از شروع HTTP نشود.\n$ curl -v -m30 -k --resolve dns.google:443:93.184.216.34 https://dns.google/ ارتباط مسدود نشده است.\nو در تست بعدی، از IP ی dns.google استفاده می کنیم و SNI را برای example.com در نظر می گیریم:\n$ curl -v -m30 -k --resolve example.com:443:8.8.4.4 https://example.com/ در نتیجه در این شبکه، بعضی از سرویس ها فقط در صورت ای مسدود خواهند شد که هم آدرس در SNI و هم آدرس IP با rule تنظیم شده در سیستم سانسور مطابقت داشته باشند. در مورد این موضوع در بخش مسدود سازی random سرویس ها باز هم توضیح داده خواهد شد.\nتشخیص تحریم از فیلتر # برای تشخیص اینکه یک ارتباط فیلتر شده است و یا به دلیل تحریم امکان ارتباط با آن وجود ندارد، باید از ارتباط HTTPS استفاده شود. به دلیل اینکه این امکان فراهم می شود تا این بررسی، از دستکاری شدن محتوایش در مسیر ارتباط در امان بماند.\nهمچنین طی یک سال اخیر، در اکثر موارد تحریم بدون نمایش خطای HTTP، از ارتباط جلوگیری نشده است. یعنی اگر تحریم صورت گرفته باشد، ما معمولا می توانیم به صورت کامل TCP handshake و TLS handshake داشته باشیم.\nبه دلیل سادگی تشخیص تحریم و پیچیدگی فیلتر، بهتر است که از OONI همانطور که توضیح داده شد استفاده کنید. اما اگر به صورت دستی می خواهید این کار را انجام دهید، می توانید ابتدا یک بار آدرس را با استفاده از شبکه ی خود تست کنید و اگر خطای HTTP ی 403 و یا 404 دریافت کردید و اما وقتی از فیلترشکن استفاده می کنید خطایی مشابه دریافت نکردید، این نشان می دهد که ارتباط با ایران تحریم شده است.\nالبته گاهی ممکن است که یک آدرس، هم تحریم و هم فیلتر شود. مانند Firebase :\nدامنه‌ی https://t.co/dJqPfPjT8M از بیخ و بن فیلتر شد؟! 😕@azarijahromi\n\u0026mdash; Shecan | شکن (@shecan_ir) May 21, 2020 آدرس های مربوط به firebase همچنین از معدود سرویس هایی هستند که اعمال تحریم توسط شان در TLS handshake و با ارسال packet های FIN,ACK انجام می شود. این مسئله را در بخش آنالیز packet ها بیشتر توضیح خواهیم داد.\n"}]